var tipuesearch = {"pages":[{"title":" x3d2 ","text":"x3d2 A re-implementation of the Xcompact3d framework. Developer Info Xcompact3d team","tags":"home","loc":"index.html"},{"title":"omp_backend_t – x3d2 ","text":"type, public, extends( base_backend_t ) :: omp_backend_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu integer, public :: nx_loc integer, public :: ny_loc integer, public :: nz_loc class( allocator_t ), public, pointer :: allocator class( dirps_t ), public, pointer :: xdirps class( dirps_t ), public, pointer :: ydirps class( dirps_t ), public, pointer :: zdirps class( poisson_fft_t ), public, pointer :: poisson_fft integer, public :: MPI_FP_PREC = dp real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_e Constructor public        interface omp_backend_t public  function init (globs, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( globs_t ) :: globs class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t ) Type-Bound Procedures procedure, public :: alloc_tdsops => alloc_omp_tdsops public  subroutine alloc_omp_tdsops (self, tdsops, n, dx, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n real(kind=dp), intent(in) :: dx character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: transeq_x => transeq_x_omp public  subroutine transeq_x_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_y => transeq_y_omp public  subroutine transeq_y_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_z => transeq_z_omp public  subroutine transeq_z_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: tds_solve => tds_solve_omp public  subroutine tds_solve_omp (self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops procedure, public :: reorder => reorder_omp public  subroutine reorder_omp (self, u_, u, direction) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction procedure, public :: sum_yintox => sum_yintox_omp public  subroutine sum_yintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure, public :: sum_zintox => sum_zintox_omp public  subroutine sum_zintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure, public :: vecadd => vecadd_omp public  subroutine vecadd_omp (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y procedure, public :: scalar_product => scalar_product_omp public  function scalar_product_omp (self, x, y) result(s) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) procedure, public :: set_field => set_field_omp public  subroutine set_field_omp (self, f, arr) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: arr procedure, public :: get_field => get_field_omp public  subroutine get_field_omp (self, arr, f) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: arr class( field_t ), intent(in) :: f procedure, public :: init_poisson_fft => init_omp_poisson_fft public  subroutine init_omp_poisson_fft (self, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: transeq_omp_dist public  subroutine transeq_omp_dist (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"type/omp_backend_t.html"},{"title":"cuda_allocator_t – x3d2 ","text":"type, public, extends( allocator_t ) :: cuda_allocator_t Components Type Visibility Attributes Name Initial integer, public :: dims (3) integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( field_t ), public, pointer :: first => null() The pointer to the first block on the list.  Non associated if\nthe list is empty Type-Bound Procedures procedure, public :: get_block public  function get_block (self) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Read more… Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value class( field_t ), pointer procedure, public :: release_block public  subroutine release_block (self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle procedure, public :: get_block_ids public  function get_block_ids (self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:) procedure, public :: destroy public  subroutine destroy (self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a field_t object automatically\ndeallocates its internal allocatable data array. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self procedure, public :: create_block => create_cuda_block public  function create_cuda_block (self, next) result(ptr) Arguments Type Intent Optional Attributes Name class( cuda_allocator_t ), intent(inout) :: self type( cuda_field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer","tags":"","loc":"type/cuda_allocator_t.html"},{"title":"cuda_field_t – x3d2 ","text":"type, public, extends( field_t ) :: cuda_field_t Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, allocatable :: data (:,:,:) integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. real(kind=dp), public, allocatable, device :: data_d (:,:,:) Constructor public        interface cuda_field_t public  function cuda_field_constructor (dims, next, id) result(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t )","tags":"","loc":"type/cuda_field_t.html"},{"title":"base_backend_t – x3d2 ","text":"type, public :: base_backend_t base_backend class defines all the abstract operations that the\nsolver class requires. For example, transport equation in solver class evaluates the\nderivatives in x, y, and z directions, and reorders the input\nfields as required. Then finally, combines all the directional\nderivatives to obtain the divergence of U*. All these high level operations solver class executes are\ndefined here using the abstract interfaces. Every backend\nimplementation extends the present abstact backend class to\ndefine the specifics of these operations based on the target\narchitecture. Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu integer, public :: nx_loc integer, public :: ny_loc integer, public :: nz_loc class( allocator_t ), public, pointer :: allocator class( dirps_t ), public, pointer :: xdirps class( dirps_t ), public, pointer :: ydirps class( dirps_t ), public, pointer :: zdirps class( poisson_fft_t ), public, pointer :: poisson_fft Type-Bound Procedures procedure( transeq_ders ), public, deferred :: transeq_x subroutine transeq_ders(self, du, dv, dw, u, v, w, dirps) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure( transeq_ders ), public, deferred :: transeq_y subroutine transeq_ders(self, du, dv, dw, u, v, w, dirps) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure( transeq_ders ), public, deferred :: transeq_z subroutine transeq_ders(self, du, dv, dw, u, v, w, dirps) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure( tds_solve ), public, deferred :: tds_solve subroutine tds_solve(self, du, u, dirps, tdsops) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops procedure( reorder ), public, deferred :: reorder subroutine reorder(self, u_, u, direction) Prototype reorder subroutines are straightforward, they rearrange\ndata into our specialist data structure so that regardless\nof the direction tridiagonal systems are solved efficiently\nand fast. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction procedure( sum_intox ), public, deferred :: sum_yintox subroutine sum_intox(self, u, u_) Prototype sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure( sum_intox ), public, deferred :: sum_zintox subroutine sum_intox(self, u, u_) Prototype sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure( vecadd ), public, deferred :: vecadd subroutine vecadd(self, a, x, b, y) Prototype adds two vectors together: y = a x + b y Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y procedure( scalar_product ), public, deferred :: scalar_product function scalar_product(self, x, y) result(s) Prototype Calculates the scalar product of two input fields Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) procedure( get_field ), public, deferred :: get_field subroutine get_field(self, arr, f) Prototype copy the specialist data structure from device or host back\nto a regular 3D data structure. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: arr class( field_t ), intent(in) :: f procedure( set_field ), public, deferred :: set_field subroutine set_field(self, f, arr) Prototype copy the initial condition stored in a regular 3D data\nstructure into the specialist data structure array on the\ndevice or host. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: arr procedure( alloc_tdsops ), public, deferred :: alloc_tdsops subroutine alloc_tdsops(self, tdsops, n, dx, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Prototype Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n real(kind=dp), intent(in) :: dx character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure( init_poisson_fft ), public, deferred :: init_poisson_fft subroutine init_poisson_fft(self, xdirps, ydirps, zdirps) Prototype Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"type/base_backend_t.html"},{"title":"omp_poisson_fft_t – x3d2 ","text":"type, public, extends( poisson_fft_t ) :: omp_poisson_fft_t FFT based Poisson solver\nIt can only handle 1D decompositions along z direction. Components Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves complex(kind=dp), public, allocatable, dimension(:) :: ax complex(kind=dp), public, allocatable, dimension(:) :: bx complex(kind=dp), public, allocatable, dimension(:) :: ay complex(kind=dp), public, allocatable, dimension(:) :: by complex(kind=dp), public, allocatable, dimension(:) :: az complex(kind=dp), public, allocatable, dimension(:) :: bz complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_x complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_y complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_z Constructor public        interface omp_poisson_fft_t private  function init(xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps Return Value type( omp_poisson_fft_t ) Type-Bound Procedures procedure, public :: base_init public  subroutine base_init (self, xdirps, ydirps, zdirps, sz) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps integer, intent(in) :: sz procedure, public :: waves_set public  subroutine waves_set (self, xdirps, ydirps, zdirps, sz) Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps integer, intent(in) :: sz procedure, public :: fft_forward => fft_forward_omp public  subroutine fft_forward_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure, public :: fft_backward => fft_backward_omp public  subroutine fft_backward_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure, public :: fft_postprocess => fft_postprocess_omp public  subroutine fft_postprocess_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self","tags":"","loc":"type/omp_poisson_fft_t.html"},{"title":"poisson_fft_t – x3d2 ","text":"type, public :: poisson_fft_t FFT based Poisson solver\nIt can only handle 1D decompositions along z direction. Components Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves complex(kind=dp), public, allocatable, dimension(:) :: ax complex(kind=dp), public, allocatable, dimension(:) :: bx complex(kind=dp), public, allocatable, dimension(:) :: ay complex(kind=dp), public, allocatable, dimension(:) :: by complex(kind=dp), public, allocatable, dimension(:) :: az complex(kind=dp), public, allocatable, dimension(:) :: bz Type-Bound Procedures procedure( fft_forward ), public, deferred :: fft_forward subroutine fft_forward(self, f_in) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure( fft_backward ), public, deferred :: fft_backward subroutine fft_backward(self, f_out) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure( fft_postprocess ), public, deferred :: fft_postprocess subroutine fft_postprocess(self) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self procedure, public :: base_init public  subroutine base_init (self, xdirps, ydirps, zdirps, sz) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps integer, intent(in) :: sz procedure, public :: waves_set public  subroutine waves_set (self, xdirps, ydirps, zdirps, sz) Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps integer, intent(in) :: sz","tags":"","loc":"type/poisson_fft_t.html"},{"title":"cuda_tdsops_t – x3d2 ","text":"type, public, extends( tdsops_t ) :: cuda_tdsops_t CUDA extension of the Tridiagonal Solver Operators class. Regular tdsops_t class is initiated and the coefficient arrays are\ncopied into device arrays so that cuda kernels can use them. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha real(kind=dp), public :: a real(kind=dp), public :: b real(kind=dp), public :: c = 0._dp real(kind=dp), public :: d = 0._dp integer, public :: n integer, public :: n_halo real(kind=dp), public, device, allocatable :: dist_fw_dev (:) real(kind=dp), public, device, allocatable :: dist_bw_dev (:) real(kind=dp), public, device, allocatable :: dist_sa_dev (:) real(kind=dp), public, device, allocatable :: dist_sc_dev (:) real(kind=dp), public, device, allocatable :: dist_af_dev (:) real(kind=dp), public, device, allocatable :: coeffs_dev (:) real(kind=dp), public, device, allocatable :: coeffs_s_dev (:,:) real(kind=dp), public, device, allocatable :: coeffs_e_dev (:,:) Constructor public        interface cuda_tdsops_t public  function cuda_tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function Type-Bound Procedures procedure, public :: preprocess public  subroutine preprocess (self, dist_b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b procedure, public :: stagder_1st public  subroutine stagder_1st (self, delta, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym procedure, public :: interpl_mid public  subroutine interpl_mid (self, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym procedure, public :: deriv_2nd public  subroutine deriv_2nd (self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: deriv_1st public  subroutine deriv_1st (self, delta, scheme, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym","tags":"","loc":"type/cuda_tdsops_t.html"},{"title":"cuda_poisson_fft_t – x3d2 ","text":"type, public, extends( poisson_fft_t ) :: cuda_poisson_fft_t FFT based Poisson solver\nIt can only handle 1D decompositions along z direction. Components Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves complex(kind=dp), public, allocatable, dimension(:) :: ax complex(kind=dp), public, allocatable, dimension(:) :: bx complex(kind=dp), public, allocatable, dimension(:) :: ay complex(kind=dp), public, allocatable, dimension(:) :: by complex(kind=dp), public, allocatable, dimension(:) :: az complex(kind=dp), public, allocatable, dimension(:) :: bz complex(kind=dp), public, device, pointer, dimension(:) :: c_x_dev Local domain sized arrays to store data in spectral space complex(kind=dp), public, device, pointer, dimension(:) :: c_y_dev Local domain sized arrays to store data in spectral space complex(kind=dp), public, device, pointer, dimension(:) :: c_z_dev Local domain sized arrays to store data in spectral space complex(kind=dp), public, device, allocatable, dimension(:, :, :) :: waves_dev Local domain sized array storing the spectral equivalence constants real(kind=dp), public, device, allocatable, dimension(:) :: ax_dev real(kind=dp), public, device, allocatable, dimension(:) :: bx_dev real(kind=dp), public, device, allocatable, dimension(:) :: ay_dev real(kind=dp), public, device, allocatable, dimension(:) :: by_dev real(kind=dp), public, device, allocatable, dimension(:) :: az_dev real(kind=dp), public, device, allocatable, dimension(:) :: bz_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: f_tmp integer, public :: planD2Zz integer, public :: planZ2Dz integer, public :: planZ2Zx integer, public :: planZ2Zy Constructor public        interface cuda_poisson_fft_t private  function init(xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps Return Value type( cuda_poisson_fft_t ) Type-Bound Procedures procedure, public :: base_init public  subroutine base_init (self, xdirps, ydirps, zdirps, sz) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps integer, intent(in) :: sz procedure, public :: waves_set public  subroutine waves_set (self, xdirps, ydirps, zdirps, sz) Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps integer, intent(in) :: sz procedure, public :: fft_forward => fft_forward_cuda public  subroutine fft_forward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f procedure, public :: fft_backward => fft_backward_cuda public  subroutine fft_backward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f procedure, public :: fft_postprocess => fft_postprocess_cuda public  subroutine fft_postprocess_cuda (self) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self","tags":"","loc":"type/cuda_poisson_fft_t.html"},{"title":"allocator_t – x3d2 ","text":"type, public :: allocator_t An instance of type allocator_t is responsible for the\nmaintenance of a linked list of instances of equal size field_t objects: ---- ---- ---- ---- ---- ---- ... -->| id = 1 | data | next |-->| id = 0 | data | next |--> null () ---- ---- ---- ---- ---- ---- the last block's next pointer being non associated. User code can request access to a memory block by using the\ntype bound procedure get_block .  If the list is\nnot empty, a pointer to the first block on the list is\nreturned and the block is detached from the list.  If the list\nis empty (i.e. all initially allocated blocks are currently\nreferenced to) then a new block is allocated before a pointer\nto it is returned. In order to reuse memory it is important that user code\nrelease blocks when they are not needed anymore.  This is done\nby calling the type bound procedure release_block .  The\nreleased block is then pushed in front of the block list. Components Type Visibility Attributes Name Initial integer, public :: dims (3) integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( field_t ), public, pointer :: first => null() The pointer to the first block on the list.  Non associated if\nthe list is empty Type-Bound Procedures procedure, public :: get_block public  function get_block (self) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Read more… Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value class( field_t ), pointer procedure, public :: release_block public  subroutine release_block (self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle procedure, public :: create_block public  function create_block (self, next) result(ptr) Allocate memory for a new block and return a pointer to a new field_t object. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self type( field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer procedure, public :: get_block_ids public  function get_block_ids (self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:) procedure, public :: destroy public  subroutine destroy (self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a field_t object automatically\ndeallocates its internal allocatable data array. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self","tags":"","loc":"type/allocator_t.html"},{"title":"field_t – x3d2 ","text":"type, public :: field_t Memory block type holding both a 3D data field and a pointer\nto the next block.  The field_t type also holds a integer refcount that counts the number of references to this\nfield.  User code is currently responsible for incrementing\nthe reference count. Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, allocatable :: data (:,:,:) integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. Constructor public        interface field_t public  function field_constructor (dims, next, id) result(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t )","tags":"","loc":"type/field_t.html"},{"title":"flist_t – x3d2 ","text":"type, public :: flist_t Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: ptr","tags":"","loc":"type/flist_t.html"},{"title":"globs_t – x3d2 ","text":"type, public :: globs_t Components Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: nx_loc integer, public :: ny_loc integer, public :: nz_loc integer, public :: n_groups_x integer, public :: n_groups_y integer, public :: n_groups_z real(kind=dp), public :: Lx real(kind=dp), public :: Ly real(kind=dp), public :: Lz real(kind=dp), public :: dx real(kind=dp), public :: dy real(kind=dp), public :: dz real(kind=dp), public :: nu real(kind=dp), public :: dt integer, public :: n_iters integer, public :: n_output integer, public :: nproc_x = 1 integer, public :: nproc_y = 1 integer, public :: nproc_z = 1 character(len=20), public :: BC_x_s character(len=20), public :: BC_x_e character(len=20), public :: BC_y_s character(len=20), public :: BC_y_e character(len=20), public :: BC_z_s character(len=20), public :: BC_z_e integer, public :: poisson_solver_type","tags":"","loc":"type/globs_t.html"},{"title":"solver_t – x3d2 ","text":"type, public :: solver_t solver class defines the Incompact3D algorithm at a very high level. Procedures defined here that are part of the Incompact3D algorithm\nare: transeq, divergence, poisson, and gradient. The operations these high level procedures require are provided by\nthe relavant backend implementations. transeq procedure obtains the derivations in x, y, and z directions\nusing the transeq_x, transeq_y, and transeq_z operations provided by\nthe backend.\nThere are two different algorithms available for this operation, a\ndistributed algorithm and the Thomas algorithm. At the solver class\nlevel it isn't known which algorithm will be executed, that is decided\nat run time and therefore backend implementations are responsible for\nexecuting the right subroutines. Allocator is responsible from giving us a field sized array when\nrequested. For example, when the derivations in x direction are\ncompleted and we are ready for the y directional derivatives, we need\nthree fields to reorder and store the velocities in y direction. Also,\nwe need three more fields for storing the results, and the get_block\nmethod of the allocator is used to arrange all these memory\nassignments. Later, when a field is no more required, release_block\nmethod of the allocator can be used to make this field available\nfor later use. Components Type Visibility Attributes Name Initial real(kind=dp), public :: dt real(kind=dp), public :: nu integer, public :: n_iters integer, public :: n_output class( field_t ), public, pointer :: u class( field_t ), public, pointer :: v class( field_t ), public, pointer :: w class( base_backend_t ), public, pointer :: backend class( dirps_t ), public, pointer :: xdirps class( dirps_t ), public, pointer :: ydirps class( dirps_t ), public, pointer :: zdirps class( time_intg_t ), public, pointer :: time_integrator procedure( poisson_solver ), public, pointer :: poisson => null() Constructor public        interface solver_t public  function init (backend, time_integrator, xdirps, ydirps, zdirps, globs) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend class( time_intg_t ), intent(inout), target :: time_integrator class( dirps_t ), intent(inout), target :: xdirps class( dirps_t ), intent(inout), target :: ydirps class( dirps_t ), intent(inout), target :: zdirps class( globs_t ), intent(in) :: globs Return Value type( solver_t ) Type-Bound Procedures procedure, public :: transeq public  subroutine transeq (self, du, dv, dw, u, v, w) Skew-symmetric form of convection-diffusion terms in the\nincompressible Navier-Stokes momemtum equations, excluding\npressure terms.\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: divergence_v2p public  subroutine divergence_v2p (self, div_u, u, v, w) Divergence of a vector field (u, v, w).\nInputs from velocity grid and outputs to pressure grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: gradient_p2v public  subroutine gradient_p2v (self, dpdx, dpdy, dpdz, pressure) Gradient of a scalar field 'pressure'.\nInputs from pressure grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: pressure procedure, public :: curl public  subroutine curl (self, o_i_hat, o_j_hat, o_k_hat, u, v, w) Curl of a vector field (u, v, w).\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: output public  subroutine output (self, t, u_out) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: self real(kind=dp), intent(in) :: t real(kind=dp), intent(inout), dimension(:, :, :) :: u_out procedure, public :: run public  subroutine run (self, u_out, v_out, w_out) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: self real(kind=dp), intent(inout), dimension(:, :, :) :: u_out real(kind=dp), intent(inout), dimension(:, :, :) :: v_out real(kind=dp), intent(inout), dimension(:, :, :) :: w_out","tags":"","loc":"type/solver_t.html"},{"title":"tdsops_t – x3d2 ","text":"type, public :: tdsops_t Tridiagonal Solver Operators class. Operator arrays are preprocessed in this class based on the arguments\nprovided. dist_fw and dist_bw are used in the first phase of the\ndistributed tridiagonal solver algorithm. dist_sa and dist_sc are used\nin the final substitution phase. See the kernels_dist.f90 files in the\nrelevant backend folders.\ncoeff arrays define the specific rules of building the RHS\ncorresponding to the tridiagonal system to be solved, and used only in\nthe first phase of the distributed algorithm when building the RHS.\nIf a boundary condition is defined then coeffs_s and coeffs_e differ\nfrom coeffs array and define the RHS rule for the first and last 4\nentries in the tridiagonal system (n_halo = 4). This class does not know about the current rank or its relative\nlocation among other ranks. All the operator arrays here are used when\nexecuting a distributed tridiagonal solver phase one or two. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha real(kind=dp), public :: a real(kind=dp), public :: b real(kind=dp), public :: c = 0._dp real(kind=dp), public :: d = 0._dp integer, public :: n integer, public :: n_halo Constructor public        interface tdsops_t public  function tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. 'n', 'delta', 'operation', and 'scheme' are necessary arguments.\nNumber of points 'n', distance between two points 'delta', the\n'operation' the tridiagonal system defines, and the 'scheme' that\nspecifies the exact scheme we choose to apply for the operation.\nThe remaining arguments are optional.\n'from_to' is necessary for interpolation and staggared derivative, and\nit can be 'v2p' or 'p2v'.\nIf the specific region the instance is operating is not a boundary\nregion, then 'bc_start' and 'bc_end' are either 'null' or not defined.\n'sym' is relevant when the boundary condition is free-slip. If sym is\n.true. then it means the field we operate on is assumed to be an even\nfunction (symmetric) accross the boundary. If it is .false. it means\nthat the field is assumed to be an odd function (anti-symmetric).\n'c_nu', 'nu0_nu' are relevant when operation is second order\nderivative and scheme is compact6-hyperviscous. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' character(len=*), intent(in), optional :: bc_start Boundary Cond. character(len=*), intent(in), optional :: bc_end Boundary Cond. logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function Type-Bound Procedures procedure, public :: preprocess public  subroutine preprocess (self, dist_b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b procedure, public :: stagder_1st public  subroutine stagder_1st (self, delta, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym procedure, public :: interpl_mid public  subroutine interpl_mid (self, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym procedure, public :: deriv_2nd public  subroutine deriv_2nd (self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: deriv_1st public  subroutine deriv_1st (self, delta, scheme, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym","tags":"","loc":"type/tdsops_t.html"},{"title":"dirps_t – x3d2 ","text":"type, public :: dirps_t Directional tridiagonal solver container. This class contains the preprocessed tridiagonal solvers for operating\nin each coordinate direction. Components Type Visibility Attributes Name Initial class( tdsops_t ), public, allocatable :: der1st class( tdsops_t ), public, allocatable :: der1st_sym class( tdsops_t ), public, allocatable :: der2nd class( tdsops_t ), public, allocatable :: der2nd_sym class( tdsops_t ), public, allocatable :: stagder_v2p class( tdsops_t ), public, allocatable :: stagder_p2v class( tdsops_t ), public, allocatable :: interpl_v2p class( tdsops_t ), public, allocatable :: interpl_p2v integer, public :: nrank integer, public :: nproc integer, public :: pnext integer, public :: pprev integer, public :: n integer, public :: n_blocks real(kind=dp), public :: L real(kind=dp), public :: d","tags":"","loc":"type/dirps_t.html"},{"title":"time_intg_t – x3d2 ","text":"type, public :: time_intg_t Components Type Visibility Attributes Name Initial integer, public :: istep integer, public :: nsteps integer, public :: nsubsteps integer, public :: order integer, public :: nvars integer, public :: nolds type( flist_t ), public, allocatable :: olds (:,:) class( base_backend_t ), public, pointer :: backend class( allocator_t ), public, pointer :: allocator Constructor public        interface time_intg_t public  function constructor (backend, allocator, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator integer, intent(in), optional :: nvars Return Value type( time_intg_t ) Type-Bound Procedures procedure, public :: step public  subroutine step (self, u, v, w, du, dv, dw, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(in) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w class( field_t ), intent(in) :: du class( field_t ), intent(in) :: dv class( field_t ), intent(in) :: dw real(kind=dp), intent(in) :: dt","tags":"","loc":"type/time_intg_t.html"},{"title":"cuda_backend_t – x3d2 ","text":"type, public, extends( base_backend_t ) :: cuda_backend_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu integer, public :: nx_loc integer, public :: ny_loc integer, public :: nz_loc class( allocator_t ), public, pointer :: allocator class( dirps_t ), public, pointer :: xdirps class( dirps_t ), public, pointer :: ydirps class( dirps_t ), public, pointer :: zdirps class( poisson_fft_t ), public, pointer :: poisson_fft integer, public :: MPI_FP_PREC = dp real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_e_dev type(dim3), public :: xblocks type(dim3), public :: xthreads type(dim3), public :: yblocks type(dim3), public :: ythreads type(dim3), public :: zblocks type(dim3), public :: zthreads Constructor public        interface cuda_backend_t public  function init (globs, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( globs_t ) :: globs class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t ) Type-Bound Procedures procedure, public :: alloc_tdsops => alloc_cuda_tdsops public  subroutine alloc_cuda_tdsops (self, tdsops, n, dx, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n real(kind=dp), intent(in) :: dx character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: transeq_x => transeq_x_cuda public  subroutine transeq_x_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_y => transeq_y_cuda public  subroutine transeq_y_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_z => transeq_z_cuda public  subroutine transeq_z_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: tds_solve => tds_solve_cuda public  subroutine tds_solve_cuda (self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops procedure, public :: reorder => reorder_cuda public  subroutine reorder_cuda (self, u_o, u_i, direction) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u_o class( field_t ), intent(in) :: u_i integer, intent(in) :: direction procedure, public :: sum_yintox => sum_yintox_cuda public  subroutine sum_yintox_cuda (self, u, u_y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_y procedure, public :: sum_zintox => sum_zintox_cuda public  subroutine sum_zintox_cuda (self, u, u_z) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_z procedure, public :: vecadd => vecadd_cuda public  subroutine vecadd_cuda (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y procedure, public :: scalar_product => scalar_product_cuda public  function scalar_product_cuda (self, x, y) result(s) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) procedure, public :: set_field => set_field_cuda public  subroutine set_field_cuda (self, f, arr) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: arr procedure, public :: get_field => get_field_cuda public  subroutine get_field_cuda (self, arr, f) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: arr class( field_t ), intent(in) :: f procedure, public :: init_poisson_fft => init_cuda_poisson_fft public  subroutine init_cuda_poisson_fft (self, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: transeq_cuda_dist public  subroutine transeq_cuda_dist (self, du, dv, dw, u, v, w, dirps, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads procedure, public :: transeq_cuda_thom public  subroutine transeq_cuda_thom (self, du, dv, dw, u, v, w, dirps) Thomas algorithm implementation. So much more easier than the\ndistributed algorithm. It is intended to work only on a single rank\nso there is no MPI communication. Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: tds_solve_dist public  subroutine tds_solve_dist (self, du, u, dirps, tdsops, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"type/cuda_backend_t.html"},{"title":"transeq_ders – x3d2","text":"interface public  subroutine transeq_ders(self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps Description transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm.","tags":"","loc":"interface/transeq_ders.html"},{"title":"tds_solve – x3d2","text":"interface public  subroutine tds_solve(self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops Description transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm.","tags":"","loc":"interface/tds_solve.html"},{"title":"reorder – x3d2","text":"interface public  subroutine reorder(self, u_, u, direction) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction Description reorder subroutines are straightforward, they rearrange\ndata into our specialist data structure so that regardless\nof the direction tridiagonal systems are solved efficiently\nand fast.","tags":"","loc":"interface/reorder.html"},{"title":"sum_intox – x3d2","text":"interface public  subroutine sum_intox(self, u, u_) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ Description sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields.","tags":"","loc":"interface/sum_intox.html"},{"title":"vecadd – x3d2","text":"interface public  subroutine vecadd(self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y Description adds two vectors together: y = a x + b y","tags":"","loc":"interface/vecadd.html"},{"title":"scalar_product – x3d2","text":"interface public  function scalar_product(self, x, y) result(s) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) Description Calculates the scalar product of two input fields","tags":"","loc":"interface/scalar_product.html"},{"title":"get_field – x3d2","text":"interface public  subroutine get_field(self, arr, f) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: arr class( field_t ), intent(in) :: f Description copy the specialist data structure from device or host back\nto a regular 3D data structure.","tags":"","loc":"interface/get_field.html"},{"title":"set_field – x3d2","text":"interface public  subroutine set_field(self, f, arr) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: arr Description copy the initial condition stored in a regular 3D data\nstructure into the specialist data structure array on the\ndevice or host.","tags":"","loc":"interface/set_field.html"},{"title":"alloc_tdsops – x3d2","text":"interface public  subroutine alloc_tdsops(self, tdsops, n, dx, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n real(kind=dp), intent(in) :: dx character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu","tags":"","loc":"interface/alloc_tdsops.html"},{"title":"init_poisson_fft – x3d2","text":"interface public  subroutine init_poisson_fft(self, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"interface/init_poisson_fft.html"},{"title":"fft_forward – x3d2","text":"interface public  subroutine fft_forward(self, f_in) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in","tags":"","loc":"interface/fft_forward.html"},{"title":"fft_backward – x3d2","text":"interface public  subroutine fft_backward(self, f_out) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out","tags":"","loc":"interface/fft_backward.html"},{"title":"fft_postprocess – x3d2","text":"interface public  subroutine fft_postprocess(self) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self","tags":"","loc":"interface/fft_postprocess.html"},{"title":"poisson_solver – x3d2","text":"interface public  subroutine poisson_solver(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u","tags":"","loc":"interface/poisson_solver.html"},{"title":"init – x3d2","text":"public  function init(globs, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( globs_t ) :: globs class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t )","tags":"","loc":"proc/init.html"},{"title":"scalar_product_omp – x3d2","text":"public  function scalar_product_omp(self, x, y) result(s) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp)","tags":"","loc":"proc/scalar_product_omp.html"},{"title":"alloc_omp_tdsops – x3d2","text":"public  subroutine alloc_omp_tdsops(self, tdsops, n, dx, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n real(kind=dp), intent(in) :: dx character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu","tags":"","loc":"proc/alloc_omp_tdsops.html"},{"title":"transeq_x_omp – x3d2","text":"public  subroutine transeq_x_omp(self, du, dv, dw, u, v, w, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_x_omp.html"},{"title":"transeq_y_omp – x3d2","text":"public  subroutine transeq_y_omp(self, du, dv, dw, u, v, w, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_y_omp.html"},{"title":"transeq_z_omp – x3d2","text":"public  subroutine transeq_z_omp(self, du, dv, dw, u, v, w, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_z_omp.html"},{"title":"transeq_omp_dist – x3d2","text":"public  subroutine transeq_omp_dist(self, du, dv, dw, u, v, w, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_omp_dist.html"},{"title":"transeq_halo_exchange – x3d2","text":"public  subroutine transeq_halo_exchange(self, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_halo_exchange.html"},{"title":"transeq_dist_component – x3d2","text":"public  subroutine transeq_dist_component(self, rhs, v, u, tdsops_du, tdsops_dud, tdsops_d2u, dirps) Computes RHS_x&#94;v following: Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: rhs class( field_t ), intent(in) :: v class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops_du class( tdsops_t ), intent(in) :: tdsops_dud class( tdsops_t ), intent(in) :: tdsops_d2u type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_dist_component.html"},{"title":"tds_solve_omp – x3d2","text":"public  subroutine tds_solve_omp(self, du, u, dirps, tdsops) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops","tags":"","loc":"proc/tds_solve_omp.html"},{"title":"tds_solve_dist – x3d2","text":"public  subroutine tds_solve_dist(self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops","tags":"","loc":"proc/tds_solve_dist.html"},{"title":"reorder_omp – x3d2","text":"public  subroutine reorder_omp(self, u_, u, direction) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction","tags":"","loc":"proc/reorder_omp.html"},{"title":"sum_yintox_omp – x3d2","text":"public  subroutine sum_yintox_omp(self, u, u_) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_","tags":"","loc":"proc/sum_yintox_omp.html"},{"title":"sum_zintox_omp – x3d2","text":"public  subroutine sum_zintox_omp(self, u, u_) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_","tags":"","loc":"proc/sum_zintox_omp.html"},{"title":"vecadd_omp – x3d2","text":"public  subroutine vecadd_omp(self, a, x, b, y) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y","tags":"","loc":"proc/vecadd_omp.html"},{"title":"copy_into_buffers – x3d2","text":"public  subroutine copy_into_buffers(u_send_s, u_send_e, u, n, n_blocks) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), dimension(:, :, :) :: u integer, intent(in) :: n integer, intent(in) :: n_blocks","tags":"","loc":"proc/copy_into_buffers.html"},{"title":"set_field_omp – x3d2","text":"public  subroutine set_field_omp(self, f, arr) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: arr","tags":"","loc":"proc/set_field_omp.html"},{"title":"get_field_omp – x3d2","text":"public  subroutine get_field_omp(self, arr, f) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: arr class( field_t ), intent(in) :: f","tags":"","loc":"proc/get_field_omp.html"},{"title":"init_omp_poisson_fft – x3d2","text":"public  subroutine init_omp_poisson_fft(self, xdirps, ydirps, zdirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"proc/init_omp_poisson_fft.html"},{"title":"omp_backend_t – x3d2","text":"public interface omp_backend_t Module Procedures public  function init (globs, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( globs_t ) :: globs class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t )","tags":"","loc":"interface/omp_backend_t.html"},{"title":"cuda_field_constructor – x3d2","text":"public  function cuda_field_constructor(dims, next, id) result(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t )","tags":"","loc":"proc/cuda_field_constructor.html"},{"title":"create_cuda_block – x3d2","text":"public  function create_cuda_block(self, next) result(ptr) Type Bound cuda_allocator_t Arguments Type Intent Optional Attributes Name class( cuda_allocator_t ), intent(inout) :: self type( cuda_field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer","tags":"","loc":"proc/create_cuda_block.html"},{"title":"cuda_field_t – x3d2","text":"public interface cuda_field_t Module Procedures public  function cuda_field_constructor (dims, next, id) result(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t )","tags":"","loc":"interface/cuda_field_t.html"},{"title":"process_spectral_div_u – x3d2","text":"public  subroutine process_spectral_div_u(div, waves, nx, ny, nz, ax, bx, ay, by, az, bz) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div complex(kind=dp), intent(in), device, dimension(:, :, :) :: waves integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz real(kind=dp), intent(in), device, dimension(:) :: ax real(kind=dp), intent(in), device, dimension(:) :: bx real(kind=dp), intent(in), device, dimension(:) :: ay real(kind=dp), intent(in), device, dimension(:) :: by real(kind=dp), intent(in), device, dimension(:) :: az real(kind=dp), intent(in), device, dimension(:) :: bz","tags":"","loc":"proc/process_spectral_div_u.html"},{"title":"reorder_cmplx_x2y_T – x3d2","text":"public  subroutine reorder_cmplx_x2y_T(u_y, u_x, nz) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: u_y complex(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_cmplx_x2y_t.html"},{"title":"reorder_cmplx_y2x_T – x3d2","text":"public  subroutine reorder_cmplx_y2x_T(u_x, u_y, nz) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: u_x complex(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_cmplx_y2x_t.html"},{"title":"reorder_cmplx_y2z_T – x3d2","text":"public  subroutine reorder_cmplx_y2z_T(u_z, u_y, nx, nz) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: u_z complex(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nx integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_cmplx_y2z_t.html"},{"title":"reorder_cmplx_z2y_T – x3d2","text":"public  subroutine reorder_cmplx_z2y_T(u_y, u_z, nx, nz) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: u_y complex(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nx integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_cmplx_z2y_t.html"},{"title":"reshapeDSF – x3d2","text":"public  subroutine reshapeDSF(uout, uin) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: uout real(kind=dp), intent(in), device, dimension(:, :, :) :: uin","tags":"","loc":"proc/reshapedsf.html"},{"title":"reshapeDSB – x3d2","text":"public  subroutine reshapeDSB(uout, uin) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: uout real(kind=dp), intent(in), device, dimension(:, :, :) :: uin","tags":"","loc":"proc/reshapedsb.html"},{"title":"reshapeCDSF – x3d2","text":"public  subroutine reshapeCDSF(uout, uin) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: uout complex(kind=dp), intent(in), device, dimension(:, :, :) :: uin","tags":"","loc":"proc/reshapecdsf.html"},{"title":"reshapeCDSB – x3d2","text":"public  subroutine reshapeCDSB(uout, uin) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: uout complex(kind=dp), intent(in), device, dimension(:, :, :) :: uin","tags":"","loc":"proc/reshapecdsb.html"},{"title":"fft_forward_omp – x3d2","text":"public  subroutine fft_forward_omp(self, f_in) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in","tags":"","loc":"proc/fft_forward_omp.html"},{"title":"fft_backward_omp – x3d2","text":"public  subroutine fft_backward_omp(self, f_out) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out","tags":"","loc":"proc/fft_backward_omp.html"},{"title":"fft_postprocess_omp – x3d2","text":"public  subroutine fft_postprocess_omp(self) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self","tags":"","loc":"proc/fft_postprocess_omp.html"},{"title":"omp_poisson_fft_t – x3d2","text":"public interface omp_poisson_fft_t Module Procedures private  function init(xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps Return Value type( omp_poisson_fft_t )","tags":"","loc":"interface/omp_poisson_fft_t.html"},{"title":"base_init – x3d2","text":"public  subroutine base_init(self, xdirps, ydirps, zdirps, sz) Type Bound poisson_fft_t Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps integer, intent(in) :: sz","tags":"","loc":"proc/base_init.html"},{"title":"waves_set – x3d2","text":"public  subroutine waves_set(self, xdirps, ydirps, zdirps, sz) Ref. JCP 228 (2009), 5989–6015, Sec 4 Type Bound poisson_fft_t Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps integer, intent(in) :: sz","tags":"","loc":"proc/waves_set.html"},{"title":"cuda_tdsops_init – x3d2","text":"public  function cuda_tdsops_init(n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function","tags":"","loc":"proc/cuda_tdsops_init.html"},{"title":"cuda_tdsops_t – x3d2","text":"public interface cuda_tdsops_t Module Procedures public  function cuda_tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function","tags":"","loc":"interface/cuda_tdsops_t.html"},{"title":"exec_dist_tds_compact – x3d2","text":"public  subroutine exec_dist_tds_compact(du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e type( cuda_tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"proc/exec_dist_tds_compact.html"},{"title":"exec_dist_transeq_3fused – x3d2","text":"public  subroutine exec_dist_transeq_3fused(r_u, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, du, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, der1st, der2nd, nu, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: r_u real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_e type( cuda_tdsops_t ), intent(in) :: der1st type( cuda_tdsops_t ), intent(in) :: der2nd real(kind=dp), intent(in) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"proc/exec_dist_transeq_3fused.html"},{"title":"reorder_x2y – x3d2","text":"public  subroutine reorder_x2y(u_y, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_x2y.html"},{"title":"reorder_x2z – x3d2","text":"public  subroutine reorder_x2z(u_z, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_x2z.html"},{"title":"reorder_y2x – x3d2","text":"public  subroutine reorder_y2x(u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_y2x.html"},{"title":"reorder_y2z – x3d2","text":"public  subroutine reorder_y2z(u_z, u_y, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nx integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_y2z.html"},{"title":"reorder_z2x – x3d2","text":"public  subroutine reorder_z2x(u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_z2x.html"},{"title":"reorder_z2y – x3d2","text":"public  subroutine reorder_z2y(u_y, u_z, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nx integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_z2y.html"},{"title":"sum_yintox – x3d2","text":"public  subroutine sum_yintox(u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz","tags":"","loc":"proc/sum_yintox.html"},{"title":"sum_zintox – x3d2","text":"public  subroutine sum_zintox(u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz","tags":"","loc":"proc/sum_zintox.html"},{"title":"axpby – x3d2","text":"public  subroutine axpby(n, alpha, x, beta, y) Arguments Type Intent Optional Attributes Name integer, intent(in), value :: n real(kind=dp), intent(in), value :: alpha real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), value :: beta real(kind=dp), intent(inout), device, dimension(:, :, :) :: y","tags":"","loc":"proc/axpby.html"},{"title":"scalar_product – x3d2","text":"public  subroutine scalar_product(s, x, y, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device :: s real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), device, dimension(:, :, :) :: y integer, intent(in), value :: n","tags":"","loc":"proc/scalar_product.html"},{"title":"buffer_copy – x3d2","text":"public  subroutine buffer_copy(u_send_s, u_send_e, u, n, n_halo) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_s real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u integer, intent(in), value :: n integer, intent(in), value :: n_halo","tags":"","loc":"proc/buffer_copy.html"},{"title":"der_univ_dist – x3d2","text":"public  subroutine der_univ_dist(du, send_u_s, send_u_e, u, u_s, u_e, coeffs_s, coeffs_e, coeffs, n, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(out), dimension(:, :) :: send_u_s real(kind=dp), intent(out), dimension(:, :) :: send_u_e real(kind=dp), intent(in), dimension(:, :) :: u real(kind=dp), intent(in), dimension(:, :) :: u_s real(kind=dp), intent(in), dimension(:, :) :: u_e real(kind=dp), intent(in), dimension(:, :) :: coeffs_s real(kind=dp), intent(in), dimension(:, :) :: coeffs_e real(kind=dp), intent(in), dimension(:) :: coeffs integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: ffr real(kind=dp), intent(in), dimension(:) :: fbc real(kind=dp), intent(in), dimension(:) :: faf","tags":"","loc":"proc/der_univ_dist.html"},{"title":"der_univ_subs – x3d2","text":"public  subroutine der_univ_subs(du, recv_u_s, recv_u_e, n, dist_sa, dist_sc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(in), dimension(:, :) :: recv_u_s real(kind=dp), intent(in), dimension(:, :) :: recv_u_e integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: dist_sa real(kind=dp), intent(in), dimension(:) :: dist_sc","tags":"","loc":"proc/der_univ_subs.html"},{"title":"der_univ_dist – x3d2","text":"public  subroutine der_univ_dist(du, send_u_s, send_u_e, u, u_s, u_e, coeffs_s, coeffs_e, coeffs, n, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_s real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_e real(kind=dp), intent(in), device, dimension(:) :: coeffs integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: ffr real(kind=dp), intent(in), device, dimension(:) :: fbc real(kind=dp), intent(in), device, dimension(:) :: faf","tags":"","loc":"proc/der_univ_dist~2.html"},{"title":"der_univ_subs – x3d2","text":"public  subroutine der_univ_subs(du, recv_u_s, recv_u_e, n, dist_sa, dist_sc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_e integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: dist_sa real(kind=dp), intent(in), device, dimension(:) :: dist_sc","tags":"","loc":"proc/der_univ_subs~2.html"},{"title":"transeq_3fused_dist – x3d2","text":"public  subroutine transeq_3fused_dist(du, dud, d2u, send_du_s, send_du_e, send_dud_s, send_dud_e, send_d2u_s, send_d2u_e, u, u_s, u_e, v, v_s, v_e, n, d1_coeffs_s, d1_coeffs_e, d1_coeffs, d1_fw, d1_bw, d1_af, d2_coeffs_s, d2_coeffs_e, d2_coeffs, d2_fw, d2_bw, d2_af) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_e integer, intent(in), value :: n real(kind=dp), intent(in), device :: d1_coeffs_s (:,:) real(kind=dp), intent(in), device :: d1_coeffs_e (:,:) real(kind=dp), intent(in), device :: d1_coeffs (:) real(kind=dp), intent(in), device :: d1_fw (:) real(kind=dp), intent(in), device :: d1_bw (:) real(kind=dp), intent(in), device :: d1_af (:) real(kind=dp), intent(in), device :: d2_coeffs_s (:,:) real(kind=dp), intent(in), device :: d2_coeffs_e (:,:) real(kind=dp), intent(in), device :: d2_coeffs (:) real(kind=dp), intent(in), device :: d2_fw (:) real(kind=dp), intent(in), device :: d2_bw (:) real(kind=dp), intent(in), device :: d2_af (:)","tags":"","loc":"proc/transeq_3fused_dist.html"},{"title":"transeq_3fused_subs – x3d2","text":"public  subroutine transeq_3fused_subs(r_u, conv, du, dud, d2u, recv_du_s, recv_du_e, recv_dud_s, recv_dud_e, recv_d2u_s, recv_d2u_e, d1_sa, d1_sc, d2_sa, d2_sc, n, nu) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: r_u real(kind=dp), intent(in), device, dimension(:, :, :) :: conv real(kind=dp), intent(in), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: dud real(kind=dp), intent(in), device, dimension(:, :, :) :: d2u real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_e real(kind=dp), intent(in), device, dimension(:) :: d1_sa real(kind=dp), intent(in), device, dimension(:) :: d1_sc real(kind=dp), intent(in), device, dimension(:) :: d2_sa real(kind=dp), intent(in), device, dimension(:) :: d2_sc integer, intent(in), value :: n real(kind=dp), intent(in), value :: nu","tags":"","loc":"proc/transeq_3fused_subs.html"},{"title":"fft_forward_cuda – x3d2","text":"public  subroutine fft_forward_cuda(self, f) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f","tags":"","loc":"proc/fft_forward_cuda.html"},{"title":"fft_backward_cuda – x3d2","text":"public  subroutine fft_backward_cuda(self, f) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f","tags":"","loc":"proc/fft_backward_cuda.html"},{"title":"fft_postprocess_cuda – x3d2","text":"public  subroutine fft_postprocess_cuda(self) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self","tags":"","loc":"proc/fft_postprocess_cuda.html"},{"title":"cuda_poisson_fft_t – x3d2","text":"public interface cuda_poisson_fft_t Module Procedures private  function init(xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps Return Value type( cuda_poisson_fft_t )","tags":"","loc":"interface/cuda_poisson_fft_t.html"},{"title":"field_constructor – x3d2","text":"public  function field_constructor(dims, next, id) result(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t )","tags":"","loc":"proc/field_constructor.html"},{"title":"create_block – x3d2","text":"public  function create_block(self, next) result(ptr) Allocate memory for a new block and return a pointer to a new field_t object. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self type( field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer","tags":"","loc":"proc/create_block.html"},{"title":"get_block – x3d2","text":"public  function get_block(self) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Example f%data => get_block() Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value class( field_t ), pointer","tags":"","loc":"proc/get_block.html"},{"title":"get_block_ids – x3d2","text":"public  function get_block_ids(self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:)","tags":"","loc":"proc/get_block_ids.html"},{"title":"release_block – x3d2","text":"public  subroutine release_block(self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle","tags":"","loc":"proc/release_block.html"},{"title":"destroy – x3d2","text":"public  subroutine destroy(self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a field_t object automatically\ndeallocates its internal allocatable data array. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self","tags":"","loc":"proc/destroy.html"},{"title":"field_t – x3d2","text":"public interface field_t Module Procedures public  function field_constructor (dims, next, id) result(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t )","tags":"","loc":"interface/field_t.html"},{"title":"sendrecv_fields – x3d2","text":"public  subroutine sendrecv_fields(f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","loc":"proc/sendrecv_fields.html"},{"title":"sendrecv_3fields – x3d2","text":"public  subroutine sendrecv_3fields(f1_recv_s, f1_recv_e, f2_recv_s, f2_recv_e, f3_recv_s, f3_recv_e, f1_send_s, f1_send_e, f2_send_s, f2_send_e, f3_send_s, f3_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","loc":"proc/sendrecv_3fields.html"},{"title":"set_pprev_pnext – x3d2","text":"public  subroutine set_pprev_pnext(xprev, xnext, yprev, ynext, zprev, znext, xnproc, ynproc, znproc, nrank) Arguments Type Intent Optional Attributes Name integer, intent(out) :: xprev integer, intent(out) :: xnext integer, intent(out) :: yprev integer, intent(out) :: ynext integer, intent(out) :: zprev integer, intent(out) :: znext integer, intent(in) :: xnproc integer, intent(in) :: ynproc integer, intent(in) :: znproc integer, intent(in) :: nrank","tags":"","loc":"proc/set_pprev_pnext.html"},{"title":"exec_dist_tds_compact – x3d2","text":"public  subroutine exec_dist_tds_compact(du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, n_block) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e type( tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_block","tags":"","loc":"proc/exec_dist_tds_compact~2.html"},{"title":"exec_dist_transeq_compact – x3d2","text":"public  subroutine exec_dist_transeq_compact(rhs, du, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, tdsops_du, tdsops_dud, tdsops_d2u, nu, nproc, pprev, pnext, n_block) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: rhs real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(out), dimension(:, :, :) :: dud real(kind=dp), intent(out), dimension(:, :, :) :: d2u real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: v real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_e type( tdsops_t ), intent(in) :: tdsops_du type( tdsops_t ), intent(in) :: tdsops_dud type( tdsops_t ), intent(in) :: tdsops_d2u real(kind=dp) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_block","tags":"","loc":"proc/exec_dist_transeq_compact.html"},{"title":"init – x3d2","text":"public  function init(backend, time_integrator, xdirps, ydirps, zdirps, globs) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend class( time_intg_t ), intent(inout), target :: time_integrator class( dirps_t ), intent(inout), target :: xdirps class( dirps_t ), intent(inout), target :: ydirps class( dirps_t ), intent(inout), target :: zdirps class( globs_t ), intent(in) :: globs Return Value type( solver_t )","tags":"","loc":"proc/init~4.html"},{"title":"allocate_tdsops – x3d2","text":"public  subroutine allocate_tdsops(dirps, nx, dx, backend) Arguments Type Intent Optional Attributes Name class( dirps_t ), intent(inout) :: dirps integer, intent(in) :: nx real(kind=dp), intent(in) :: dx class( base_backend_t ), intent(in) :: backend","tags":"","loc":"proc/allocate_tdsops.html"},{"title":"transeq – x3d2","text":"public  subroutine transeq(self, du, dv, dw, u, v, w) Skew-symmetric form of convection-diffusion terms in the\nincompressible Navier-Stokes momemtum equations, excluding\npressure terms.\nInputs from velocity grid and outputs to velocity grid. Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w","tags":"","loc":"proc/transeq.html"},{"title":"divergence_v2p – x3d2","text":"public  subroutine divergence_v2p(self, div_u, u, v, w) Divergence of a vector field (u, v, w).\nInputs from velocity grid and outputs to pressure grid. Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w","tags":"","loc":"proc/divergence_v2p.html"},{"title":"gradient_p2v – x3d2","text":"public  subroutine gradient_p2v(self, dpdx, dpdy, dpdz, pressure) Gradient of a scalar field 'pressure'.\nInputs from pressure grid and outputs to velocity grid. Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: pressure","tags":"","loc":"proc/gradient_p2v.html"},{"title":"curl – x3d2","text":"public  subroutine curl(self, o_i_hat, o_j_hat, o_k_hat, u, v, w) Curl of a vector field (u, v, w).\nInputs from velocity grid and outputs to velocity grid. Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w","tags":"","loc":"proc/curl.html"},{"title":"poisson_fft – x3d2","text":"public  subroutine poisson_fft(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u","tags":"","loc":"proc/poisson_fft.html"},{"title":"poisson_cg – x3d2","text":"public  subroutine poisson_cg(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u","tags":"","loc":"proc/poisson_cg.html"},{"title":"output – x3d2","text":"public  subroutine output(self, t, u_out) Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: self real(kind=dp), intent(in) :: t real(kind=dp), intent(inout), dimension(:, :, :) :: u_out","tags":"","loc":"proc/output.html"},{"title":"run – x3d2","text":"public  subroutine run(self, u_out, v_out, w_out) Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: self real(kind=dp), intent(inout), dimension(:, :, :) :: u_out real(kind=dp), intent(inout), dimension(:, :, :) :: v_out real(kind=dp), intent(inout), dimension(:, :, :) :: w_out","tags":"","loc":"proc/run.html"},{"title":"solver_t – x3d2","text":"public interface solver_t Module Procedures public  function init (backend, time_integrator, xdirps, ydirps, zdirps, globs) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend class( time_intg_t ), intent(inout), target :: time_integrator class( dirps_t ), intent(inout), target :: xdirps class( dirps_t ), intent(inout), target :: ydirps class( dirps_t ), intent(inout), target :: zdirps class( globs_t ), intent(in) :: globs Return Value type( solver_t )","tags":"","loc":"interface/solver_t.html"},{"title":"tdsops_init – x3d2","text":"public  function tdsops_init(n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. 'n', 'delta', 'operation', and 'scheme' are necessary arguments.\nNumber of points 'n', distance between two points 'delta', the\n'operation' the tridiagonal system defines, and the 'scheme' that\nspecifies the exact scheme we choose to apply for the operation.\nThe remaining arguments are optional.\n'from_to' is necessary for interpolation and staggared derivative, and\nit can be 'v2p' or 'p2v'.\nIf the specific region the instance is operating is not a boundary\nregion, then 'bc_start' and 'bc_end' are either 'null' or not defined.\n'sym' is relevant when the boundary condition is free-slip. If sym is\n.true. then it means the field we operate on is assumed to be an even\nfunction (symmetric) accross the boundary. If it is .false. it means\nthat the field is assumed to be an odd function (anti-symmetric).\n'c_nu', 'nu0_nu' are relevant when operation is second order\nderivative and scheme is compact6-hyperviscous. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' character(len=*), intent(in), optional :: bc_start Boundary Cond. character(len=*), intent(in), optional :: bc_end Boundary Cond. logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function","tags":"","loc":"proc/tdsops_init.html"},{"title":"deriv_1st – x3d2","text":"public  subroutine deriv_1st(self, delta, scheme, bc_start, bc_end, sym) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym","tags":"","loc":"proc/deriv_1st.html"},{"title":"deriv_2nd – x3d2","text":"public  subroutine deriv_2nd(self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu","tags":"","loc":"proc/deriv_2nd.html"},{"title":"interpl_mid – x3d2","text":"public  subroutine interpl_mid(self, scheme, from_to, bc_start, bc_end, sym) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym","tags":"","loc":"proc/interpl_mid.html"},{"title":"stagder_1st – x3d2","text":"public  subroutine stagder_1st(self, delta, scheme, from_to, bc_start, bc_end, sym) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym","tags":"","loc":"proc/stagder_1st.html"},{"title":"preprocess – x3d2","text":"public  subroutine preprocess(self, dist_b) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b","tags":"","loc":"proc/preprocess.html"},{"title":"tdsops_t – x3d2","text":"public interface tdsops_t Module Procedures public  function tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' character(len=*), intent(in), optional :: bc_start Boundary Cond. character(len=*), intent(in), optional :: bc_end Boundary Cond. logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function","tags":"","loc":"interface/tdsops_t.html"},{"title":"constructor – x3d2","text":"public  function constructor(backend, allocator, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator integer, intent(in), optional :: nvars Return Value type( time_intg_t )","tags":"","loc":"proc/constructor.html"},{"title":"step – x3d2","text":"public  subroutine step(self, u, v, w, du, dv, dw, dt) Type Bound time_intg_t Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(in) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w class( field_t ), intent(in) :: du class( field_t ), intent(in) :: dv class( field_t ), intent(in) :: dw real(kind=dp), intent(in) :: dt","tags":"","loc":"proc/step.html"},{"title":"adams_bashford_1st – x3d2","text":"public  subroutine adams_bashford_1st(vels, olds, coeffs) Arguments Type Intent Optional Attributes Name type( flist_t ) :: vels (:) type( flist_t ) :: olds (:) real :: coeffs (:)","tags":"","loc":"proc/adams_bashford_1st.html"},{"title":"time_intg_t – x3d2","text":"public interface time_intg_t Module Procedures public  function constructor (backend, allocator, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator integer, intent(in), optional :: nvars Return Value type( time_intg_t )","tags":"","loc":"interface/time_intg_t.html"},{"title":"sendrecv_fields – x3d2","text":"public  subroutine sendrecv_fields(f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","loc":"proc/sendrecv_fields~2.html"},{"title":"init – x3d2","text":"public  function init(globs, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( globs_t ) :: globs class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t )","tags":"","loc":"proc/init~5.html"},{"title":"scalar_product_cuda – x3d2","text":"public  function scalar_product_cuda(self, x, y) result(s) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp)","tags":"","loc":"proc/scalar_product_cuda.html"},{"title":"alloc_cuda_tdsops – x3d2","text":"public  subroutine alloc_cuda_tdsops(self, tdsops, n, dx, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n real(kind=dp), intent(in) :: dx character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu","tags":"","loc":"proc/alloc_cuda_tdsops.html"},{"title":"transeq_x_cuda – x3d2","text":"public  subroutine transeq_x_cuda(self, du, dv, dw, u, v, w, dirps) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_x_cuda.html"},{"title":"transeq_y_cuda – x3d2","text":"public  subroutine transeq_y_cuda(self, du, dv, dw, u, v, w, dirps) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_y_cuda.html"},{"title":"transeq_z_cuda – x3d2","text":"public  subroutine transeq_z_cuda(self, du, dv, dw, u, v, w, dirps) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_z_cuda.html"},{"title":"transeq_cuda_dist – x3d2","text":"public  subroutine transeq_cuda_dist(self, du, dv, dw, u, v, w, dirps, blocks, threads) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"proc/transeq_cuda_dist.html"},{"title":"transeq_cuda_thom – x3d2","text":"public  subroutine transeq_cuda_thom(self, du, dv, dw, u, v, w, dirps) Thomas algorithm implementation. So much more easier than the\ndistributed algorithm. It is intended to work only on a single rank\nso there is no MPI communication. Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_cuda_thom.html"},{"title":"tds_solve_cuda – x3d2","text":"public  subroutine tds_solve_cuda(self, du, u, dirps, tdsops) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops","tags":"","loc":"proc/tds_solve_cuda.html"},{"title":"tds_solve_dist – x3d2","text":"public  subroutine tds_solve_dist(self, du, u, dirps, tdsops, blocks, threads) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"proc/tds_solve_dist~2.html"},{"title":"reorder_cuda – x3d2","text":"public  subroutine reorder_cuda(self, u_o, u_i, direction) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u_o class( field_t ), intent(in) :: u_i integer, intent(in) :: direction","tags":"","loc":"proc/reorder_cuda.html"},{"title":"sum_yintox_cuda – x3d2","text":"public  subroutine sum_yintox_cuda(self, u, u_y) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_y","tags":"","loc":"proc/sum_yintox_cuda.html"},{"title":"sum_zintox_cuda – x3d2","text":"public  subroutine sum_zintox_cuda(self, u, u_z) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_z","tags":"","loc":"proc/sum_zintox_cuda.html"},{"title":"vecadd_cuda – x3d2","text":"public  subroutine vecadd_cuda(self, a, x, b, y) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y","tags":"","loc":"proc/vecadd_cuda.html"},{"title":"copy_into_buffers – x3d2","text":"public  subroutine copy_into_buffers(u_send_s_dev, u_send_e_dev, u_dev, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_s_dev real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_e_dev real(kind=dp), intent(in), device, dimension(:, :, :) :: u_dev integer, intent(in) :: n","tags":"","loc":"proc/copy_into_buffers~2.html"},{"title":"set_field_cuda – x3d2","text":"public  subroutine set_field_cuda(self, f, arr) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: arr","tags":"","loc":"proc/set_field_cuda.html"},{"title":"get_field_cuda – x3d2","text":"public  subroutine get_field_cuda(self, arr, f) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: arr class( field_t ), intent(in) :: f","tags":"","loc":"proc/get_field_cuda.html"},{"title":"init_cuda_poisson_fft – x3d2","text":"public  subroutine init_cuda_poisson_fft(self, xdirps, ydirps, zdirps) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"proc/init_cuda_poisson_fft.html"},{"title":"cuda_backend_t – x3d2","text":"public interface cuda_backend_t Module Procedures public  function init (globs, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( globs_t ) :: globs class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t )","tags":"","loc":"interface/cuda_backend_t.html"},{"title":"m_omp_backend – x3d2","text":"Uses m_omp_common m_omp_sendrecv m_omp_poisson_fft m_common m_omp_exec_dist m_allocator m_tdsops m_base_backend Interfaces public        interface omp_backend_t public  function init (globs, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( globs_t ) :: globs class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t ) Derived Types type, public, extends( base_backend_t ) :: omp_backend_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu integer, public :: nx_loc integer, public :: ny_loc integer, public :: nz_loc class( allocator_t ), public, pointer :: allocator class( dirps_t ), public, pointer :: xdirps class( dirps_t ), public, pointer :: ydirps class( dirps_t ), public, pointer :: zdirps class( poisson_fft_t ), public, pointer :: poisson_fft integer, public :: MPI_FP_PREC = dp real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_e Constructor public\n\n                    \n                    function init (globs, allocator) Type-Bound Procedures procedure, public :: alloc_tdsops => alloc_omp_tdsops procedure, public :: transeq_x => transeq_x_omp procedure, public :: transeq_y => transeq_y_omp procedure, public :: transeq_z => transeq_z_omp procedure, public :: tds_solve => tds_solve_omp procedure, public :: reorder => reorder_omp procedure, public :: sum_yintox => sum_yintox_omp procedure, public :: sum_zintox => sum_zintox_omp procedure, public :: vecadd => vecadd_omp procedure, public :: scalar_product => scalar_product_omp procedure, public :: set_field => set_field_omp procedure, public :: get_field => get_field_omp procedure, public :: init_poisson_fft => init_omp_poisson_fft procedure, public :: transeq_omp_dist Functions public  function init (globs, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( globs_t ) :: globs class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t ) public  function scalar_product_omp (self, x, y) result(s) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) Subroutines public  subroutine alloc_omp_tdsops (self, tdsops, n, dx, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n real(kind=dp), intent(in) :: dx character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu public  subroutine transeq_x_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_y_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_z_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_omp_dist (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_halo_exchange (self, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_dist_component (self, rhs, v, u, tdsops_du, tdsops_dud, tdsops_d2u, dirps) Computes RHS_x&#94;v following: Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: rhs class( field_t ), intent(in) :: v class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops_du class( tdsops_t ), intent(in) :: tdsops_dud class( tdsops_t ), intent(in) :: tdsops_d2u type( dirps_t ), intent(in) :: dirps public  subroutine tds_solve_omp (self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops public  subroutine tds_solve_dist (self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops public  subroutine reorder_omp (self, u_, u, direction) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction public  subroutine sum_yintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ public  subroutine sum_zintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ public  subroutine vecadd_omp (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y public  subroutine copy_into_buffers (u_send_s, u_send_e, u, n, n_blocks) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), dimension(:, :, :) :: u integer, intent(in) :: n integer, intent(in) :: n_blocks public  subroutine set_field_omp (self, f, arr) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: arr public  subroutine get_field_omp (self, arr, f) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: arr class( field_t ), intent(in) :: f public  subroutine init_omp_poisson_fft (self, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"module/m_omp_backend.html"},{"title":"m_cuda_allocator – x3d2","text":"Uses m_common m_allocator Interfaces public        interface cuda_field_t public  function cuda_field_constructor (dims, next, id) result(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t ) Derived Types type, public, extends( allocator_t ) :: cuda_allocator_t Components Type Visibility Attributes Name Initial integer, public :: dims (3) integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( field_t ), public, pointer :: first => null() The pointer to the first block on the list.  Non associated if\nthe list is empty Type-Bound Procedures procedure, public :: get_block procedure, public :: release_block procedure, public :: get_block_ids procedure, public :: destroy procedure, public :: create_block => create_cuda_block type, public, extends( field_t ) :: cuda_field_t Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, allocatable :: data (:,:,:) integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. real(kind=dp), public, allocatable, device :: data_d (:,:,:) Constructor public\n\n                    \n                    function cuda_field_constructor (dims, next, id) Functions public  function cuda_field_constructor (dims, next, id) result(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t ) public  function create_cuda_block (self, next) result(ptr) Arguments Type Intent Optional Attributes Name class( cuda_allocator_t ), intent(inout) :: self type( cuda_field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer","tags":"","loc":"module/m_cuda_allocator.html"},{"title":"m_cuda_complex – x3d2","text":"Uses m_common m_cuda_common cudafor Subroutines public  subroutine process_spectral_div_u (div, waves, nx, ny, nz, ax, bx, ay, by, az, bz) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div complex(kind=dp), intent(in), device, dimension(:, :, :) :: waves integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz real(kind=dp), intent(in), device, dimension(:) :: ax real(kind=dp), intent(in), device, dimension(:) :: bx real(kind=dp), intent(in), device, dimension(:) :: ay real(kind=dp), intent(in), device, dimension(:) :: by real(kind=dp), intent(in), device, dimension(:) :: az real(kind=dp), intent(in), device, dimension(:) :: bz public  subroutine reorder_cmplx_x2y_T (u_y, u_x, nz) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: u_y complex(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz public  subroutine reorder_cmplx_y2x_T (u_x, u_y, nz) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: u_x complex(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz public  subroutine reorder_cmplx_y2z_T (u_z, u_y, nx, nz) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: u_z complex(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nx integer, intent(in), value :: nz public  subroutine reorder_cmplx_z2y_T (u_y, u_z, nx, nz) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: u_y complex(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nx integer, intent(in), value :: nz public  subroutine reshapeDSF (uout, uin) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: uout real(kind=dp), intent(in), device, dimension(:, :, :) :: uin public  subroutine reshapeDSB (uout, uin) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: uout real(kind=dp), intent(in), device, dimension(:, :, :) :: uin public  subroutine reshapeCDSF (uout, uin) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: uout complex(kind=dp), intent(in), device, dimension(:, :, :) :: uin public  subroutine reshapeCDSB (uout, uin) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out), device, dimension(:, :, :) :: uout complex(kind=dp), intent(in), device, dimension(:, :, :) :: uin","tags":"","loc":"module/m_cuda_complex.html"},{"title":"m_base_backend – x3d2","text":"Uses m_common m_allocator m_poisson_fft m_tdsops Abstract Interfaces abstract interface public  subroutine transeq_ders(self, du, dv, dw, u, v, w, dirps) transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps abstract interface public  subroutine tds_solve(self, du, u, dirps, tdsops) transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops abstract interface public  subroutine reorder(self, u_, u, direction) reorder subroutines are straightforward, they rearrange\ndata into our specialist data structure so that regardless\nof the direction tridiagonal systems are solved efficiently\nand fast. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction abstract interface public  subroutine sum_intox(self, u, u_) sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ abstract interface public  subroutine vecadd(self, a, x, b, y) adds two vectors together: y = a x + b y Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y abstract interface public  function scalar_product(self, x, y) result(s) Calculates the scalar product of two input fields Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) abstract interface public  subroutine get_field(self, arr, f) copy the specialist data structure from device or host back\nto a regular 3D data structure. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: arr class( field_t ), intent(in) :: f abstract interface public  subroutine set_field(self, f, arr) copy the initial condition stored in a regular 3D data\nstructure into the specialist data structure array on the\ndevice or host. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: arr abstract interface public  subroutine alloc_tdsops(self, tdsops, n, dx, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n real(kind=dp), intent(in) :: dx character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu abstract interface public  subroutine init_poisson_fft(self, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps Derived Types type, public :: base_backend_t base_backend class defines all the abstract operations that the\nsolver class requires. Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu integer, public :: nx_loc integer, public :: ny_loc integer, public :: nz_loc class( allocator_t ), public, pointer :: allocator class( dirps_t ), public, pointer :: xdirps class( dirps_t ), public, pointer :: ydirps class( dirps_t ), public, pointer :: zdirps class( poisson_fft_t ), public, pointer :: poisson_fft Type-Bound Procedures procedure( transeq_ders ), public, deferred :: transeq_x procedure( transeq_ders ), public, deferred :: transeq_y procedure( transeq_ders ), public, deferred :: transeq_z procedure( tds_solve ), public, deferred :: tds_solve procedure( reorder ), public, deferred :: reorder procedure( sum_intox ), public, deferred :: sum_yintox procedure( sum_intox ), public, deferred :: sum_zintox procedure( vecadd ), public, deferred :: vecadd procedure( scalar_product ), public, deferred :: scalar_product procedure( get_field ), public, deferred :: get_field procedure( set_field ), public, deferred :: set_field procedure( alloc_tdsops ), public, deferred :: alloc_tdsops procedure( init_poisson_fft ), public, deferred :: init_poisson_fft","tags":"","loc":"module/m_base_backend.html"},{"title":"m_omp_poisson_fft – x3d2","text":"Uses m_omp_common m_common m_allocator m_tdsops m_poisson_fft Interfaces public        interface omp_poisson_fft_t private  function init(xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps Return Value type( omp_poisson_fft_t ) Derived Types type, public, extends( poisson_fft_t ) :: omp_poisson_fft_t FFT based Poisson solver\nIt can only handle 1D decompositions along z direction. Components Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves complex(kind=dp), public, allocatable, dimension(:) :: ax complex(kind=dp), public, allocatable, dimension(:) :: bx complex(kind=dp), public, allocatable, dimension(:) :: ay complex(kind=dp), public, allocatable, dimension(:) :: by complex(kind=dp), public, allocatable, dimension(:) :: az complex(kind=dp), public, allocatable, dimension(:) :: bz complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_x complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_y complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_z Constructor private\n\n                    \n                    function init (xdirps, ydirps, zdirps) Type-Bound Procedures procedure, public :: base_init procedure, public :: waves_set procedure, public :: fft_forward => fft_forward_omp procedure, public :: fft_backward => fft_backward_omp procedure, public :: fft_postprocess => fft_postprocess_omp Subroutines public  subroutine fft_forward_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in public  subroutine fft_backward_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out public  subroutine fft_postprocess_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self","tags":"","loc":"module/m_omp_poisson_fft.html"},{"title":"m_poisson_fft – x3d2","text":"Uses m_common m_allocator m_tdsops Abstract Interfaces abstract interface public  subroutine fft_forward(self, f_in) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in abstract interface public  subroutine fft_backward(self, f_out) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out abstract interface public  subroutine fft_postprocess(self) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self Derived Types type, public :: poisson_fft_t FFT based Poisson solver\nIt can only handle 1D decompositions along z direction. Components Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves complex(kind=dp), public, allocatable, dimension(:) :: ax complex(kind=dp), public, allocatable, dimension(:) :: bx complex(kind=dp), public, allocatable, dimension(:) :: ay complex(kind=dp), public, allocatable, dimension(:) :: by complex(kind=dp), public, allocatable, dimension(:) :: az complex(kind=dp), public, allocatable, dimension(:) :: bz Type-Bound Procedures procedure( fft_forward ), public, deferred :: fft_forward procedure( fft_backward ), public, deferred :: fft_backward procedure( fft_postprocess ), public, deferred :: fft_postprocess procedure, public :: base_init procedure, public :: waves_set Subroutines public  subroutine base_init (self, xdirps, ydirps, zdirps, sz) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps integer, intent(in) :: sz public  subroutine waves_set (self, xdirps, ydirps, zdirps, sz) Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps integer, intent(in) :: sz","tags":"","loc":"module/m_poisson_fft.html"},{"title":"m_cuda_tdsops – x3d2","text":"Uses iso_fortran_env m_common m_tdsops Interfaces public        interface cuda_tdsops_t public  function cuda_tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function Derived Types type, public, extends( tdsops_t ) :: cuda_tdsops_t CUDA extension of the Tridiagonal Solver Operators class. Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha real(kind=dp), public :: a real(kind=dp), public :: b real(kind=dp), public :: c = 0._dp real(kind=dp), public :: d = 0._dp integer, public :: n integer, public :: n_halo real(kind=dp), public, device, allocatable :: dist_fw_dev (:) real(kind=dp), public, device, allocatable :: dist_bw_dev (:) real(kind=dp), public, device, allocatable :: dist_sa_dev (:) real(kind=dp), public, device, allocatable :: dist_sc_dev (:) real(kind=dp), public, device, allocatable :: dist_af_dev (:) real(kind=dp), public, device, allocatable :: coeffs_dev (:) real(kind=dp), public, device, allocatable :: coeffs_s_dev (:,:) real(kind=dp), public, device, allocatable :: coeffs_e_dev (:,:) Constructor public\n\n                    \n                    function cuda_tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Type-Bound Procedures procedure, public :: preprocess procedure, public :: stagder_1st procedure, public :: interpl_mid procedure, public :: deriv_2nd procedure, public :: deriv_1st Functions public  function cuda_tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function","tags":"","loc":"module/m_cuda_tdsops.html"},{"title":"m_cuda_exec_dist – x3d2","text":"Uses m_common cudafor m_cuda_sendrecv m_cuda_common mpi m_cuda_kernels_dist m_cuda_tdsops Subroutines public  subroutine exec_dist_tds_compact (du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e type( cuda_tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads public  subroutine exec_dist_transeq_3fused (r_u, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, du, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, der1st, der2nd, nu, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: r_u real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_e type( cuda_tdsops_t ), intent(in) :: der1st type( cuda_tdsops_t ), intent(in) :: der2nd real(kind=dp), intent(in) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"module/m_cuda_exec_dist.html"},{"title":"m_cuda_kernels_reorder – x3d2","text":"Uses m_common m_cuda_common cudafor Subroutines public  subroutine reorder_x2y (u_y, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz public  subroutine reorder_x2z (u_z, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz public  subroutine reorder_y2x (u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz public  subroutine reorder_y2z (u_z, u_y, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nx integer, intent(in), value :: nz public  subroutine reorder_z2x (u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz public  subroutine reorder_z2y (u_y, u_z, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nx integer, intent(in), value :: nz public  subroutine sum_yintox (u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz public  subroutine sum_zintox (u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz public  subroutine axpby (n, alpha, x, beta, y) Arguments Type Intent Optional Attributes Name integer, intent(in), value :: n real(kind=dp), intent(in), value :: alpha real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), value :: beta real(kind=dp), intent(inout), device, dimension(:, :, :) :: y public  subroutine scalar_product (s, x, y, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device :: s real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), device, dimension(:, :, :) :: y integer, intent(in), value :: n public  subroutine buffer_copy (u_send_s, u_send_e, u, n, n_halo) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_s real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u integer, intent(in), value :: n integer, intent(in), value :: n_halo","tags":"","loc":"module/m_cuda_kernels_reorder.html"},{"title":"m_cuda_common – x3d2","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: SZ = 32","tags":"","loc":"module/m_cuda_common.html"},{"title":"m_omp_common – x3d2","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: SZ = 16","tags":"","loc":"module/m_omp_common.html"},{"title":"m_omp_kernels_dist – x3d2","text":"Uses m_common omp_lib m_omp_common Subroutines public  subroutine der_univ_dist (du, send_u_s, send_u_e, u, u_s, u_e, coeffs_s, coeffs_e, coeffs, n, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(out), dimension(:, :) :: send_u_s real(kind=dp), intent(out), dimension(:, :) :: send_u_e real(kind=dp), intent(in), dimension(:, :) :: u real(kind=dp), intent(in), dimension(:, :) :: u_s real(kind=dp), intent(in), dimension(:, :) :: u_e real(kind=dp), intent(in), dimension(:, :) :: coeffs_s real(kind=dp), intent(in), dimension(:, :) :: coeffs_e real(kind=dp), intent(in), dimension(:) :: coeffs integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: ffr real(kind=dp), intent(in), dimension(:) :: fbc real(kind=dp), intent(in), dimension(:) :: faf public  subroutine der_univ_subs (du, recv_u_s, recv_u_e, n, dist_sa, dist_sc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(in), dimension(:, :) :: recv_u_s real(kind=dp), intent(in), dimension(:, :) :: recv_u_e integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: dist_sa real(kind=dp), intent(in), dimension(:) :: dist_sc","tags":"","loc":"module/m_omp_kernels_dist.html"},{"title":"m_cuda_kernels_dist – x3d2","text":"Uses m_common cudafor Subroutines public  subroutine der_univ_dist (du, send_u_s, send_u_e, u, u_s, u_e, coeffs_s, coeffs_e, coeffs, n, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_s real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_e real(kind=dp), intent(in), device, dimension(:) :: coeffs integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: ffr real(kind=dp), intent(in), device, dimension(:) :: fbc real(kind=dp), intent(in), device, dimension(:) :: faf public  subroutine der_univ_subs (du, recv_u_s, recv_u_e, n, dist_sa, dist_sc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_e integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: dist_sa real(kind=dp), intent(in), device, dimension(:) :: dist_sc public  subroutine transeq_3fused_dist (du, dud, d2u, send_du_s, send_du_e, send_dud_s, send_dud_e, send_d2u_s, send_d2u_e, u, u_s, u_e, v, v_s, v_e, n, d1_coeffs_s, d1_coeffs_e, d1_coeffs, d1_fw, d1_bw, d1_af, d2_coeffs_s, d2_coeffs_e, d2_coeffs, d2_fw, d2_bw, d2_af) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_e integer, intent(in), value :: n real(kind=dp), intent(in), device :: d1_coeffs_s (:,:) real(kind=dp), intent(in), device :: d1_coeffs_e (:,:) real(kind=dp), intent(in), device :: d1_coeffs (:) real(kind=dp), intent(in), device :: d1_fw (:) real(kind=dp), intent(in), device :: d1_bw (:) real(kind=dp), intent(in), device :: d1_af (:) real(kind=dp), intent(in), device :: d2_coeffs_s (:,:) real(kind=dp), intent(in), device :: d2_coeffs_e (:,:) real(kind=dp), intent(in), device :: d2_coeffs (:) real(kind=dp), intent(in), device :: d2_fw (:) real(kind=dp), intent(in), device :: d2_bw (:) real(kind=dp), intent(in), device :: d2_af (:) public  subroutine transeq_3fused_subs (r_u, conv, du, dud, d2u, recv_du_s, recv_du_e, recv_dud_s, recv_dud_e, recv_d2u_s, recv_d2u_e, d1_sa, d1_sc, d2_sa, d2_sc, n, nu) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: r_u real(kind=dp), intent(in), device, dimension(:, :, :) :: conv real(kind=dp), intent(in), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: dud real(kind=dp), intent(in), device, dimension(:, :, :) :: d2u real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_e real(kind=dp), intent(in), device, dimension(:) :: d1_sa real(kind=dp), intent(in), device, dimension(:) :: d1_sc real(kind=dp), intent(in), device, dimension(:) :: d2_sa real(kind=dp), intent(in), device, dimension(:) :: d2_sc integer, intent(in), value :: n real(kind=dp), intent(in), value :: nu","tags":"","loc":"module/m_cuda_kernels_dist.html"},{"title":"m_cuda_poisson_fft – x3d2","text":"Uses m_cuda_complex m_cuda_allocator m_common cudafor m_allocator m_cuda_common cufft m_tdsops m_poisson_fft Interfaces public        interface cuda_poisson_fft_t private  function init(xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps Return Value type( cuda_poisson_fft_t ) Derived Types type, public, extends( poisson_fft_t ) :: cuda_poisson_fft_t FFT based Poisson solver\nIt can only handle 1D decompositions along z direction. Components Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves complex(kind=dp), public, allocatable, dimension(:) :: ax complex(kind=dp), public, allocatable, dimension(:) :: bx complex(kind=dp), public, allocatable, dimension(:) :: ay complex(kind=dp), public, allocatable, dimension(:) :: by complex(kind=dp), public, allocatable, dimension(:) :: az complex(kind=dp), public, allocatable, dimension(:) :: bz complex(kind=dp), public, device, pointer, dimension(:) :: c_x_dev Local domain sized arrays to store data in spectral space complex(kind=dp), public, device, pointer, dimension(:) :: c_y_dev Local domain sized arrays to store data in spectral space complex(kind=dp), public, device, pointer, dimension(:) :: c_z_dev Local domain sized arrays to store data in spectral space complex(kind=dp), public, device, allocatable, dimension(:, :, :) :: waves_dev Local domain sized array storing the spectral equivalence constants real(kind=dp), public, device, allocatable, dimension(:) :: ax_dev real(kind=dp), public, device, allocatable, dimension(:) :: bx_dev real(kind=dp), public, device, allocatable, dimension(:) :: ay_dev real(kind=dp), public, device, allocatable, dimension(:) :: by_dev real(kind=dp), public, device, allocatable, dimension(:) :: az_dev real(kind=dp), public, device, allocatable, dimension(:) :: bz_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: f_tmp integer, public :: planD2Zz integer, public :: planZ2Dz integer, public :: planZ2Zx integer, public :: planZ2Zy Constructor private\n\n                    \n                    function init (xdirps, ydirps, zdirps) Type-Bound Procedures procedure, public :: base_init procedure, public :: waves_set procedure, public :: fft_forward => fft_forward_cuda procedure, public :: fft_backward => fft_backward_cuda procedure, public :: fft_postprocess => fft_postprocess_cuda Subroutines public  subroutine fft_forward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f public  subroutine fft_backward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f public  subroutine fft_postprocess_cuda (self) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self","tags":"","loc":"module/m_cuda_poisson_fft.html"},{"title":"m_allocator – x3d2","text":"Uses m_common Interfaces public        interface field_t public  function field_constructor (dims, next, id) result(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t ) Derived Types type, public :: allocator_t An instance of type allocator_t is responsible for the\nmaintenance of a linked list of instances of equal size field_t objects: Read more… Components Type Visibility Attributes Name Initial integer, public :: dims (3) integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( field_t ), public, pointer :: first => null() The pointer to the first block on the list.  Non associated if\nthe list is empty Type-Bound Procedures procedure, public :: get_block procedure, public :: release_block procedure, public :: create_block procedure, public :: get_block_ids procedure, public :: destroy type, public :: field_t Memory block type holding both a 3D data field and a pointer\nto the next block.  The field_t type also holds a integer refcount that counts the number of references to this\nfield.  User code is currently responsible for incrementing\nthe reference count. Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, allocatable :: data (:,:,:) integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. Constructor public\n\n                    \n                    function field_constructor (dims, next, id) type, public :: flist_t Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: ptr Functions public  function field_constructor (dims, next, id) result(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t ) public  function create_block (self, next) result(ptr) Allocate memory for a new block and return a pointer to a new field_t object. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self type( field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer public  function get_block (self) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Read more… Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value class( field_t ), pointer public  function get_block_ids (self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:) Subroutines public  subroutine release_block (self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle public  subroutine destroy (self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a field_t object automatically\ndeallocates its internal allocatable data array. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self","tags":"","loc":"module/m_allocator.html"},{"title":"m_cuda_sendrecv – x3d2","text":"Uses mpi m_common cudafor Subroutines public  subroutine sendrecv_fields (f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next public  subroutine sendrecv_3fields (f1_recv_s, f1_recv_e, f2_recv_s, f2_recv_e, f3_recv_s, f3_recv_e, f1_send_s, f1_send_e, f2_send_s, f2_send_e, f3_send_s, f3_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","loc":"module/m_cuda_sendrecv.html"},{"title":"m_common – x3d2","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = kind(0.0d0) real(kind=dp), public, parameter :: pi = 4*atan(1.0_dp) integer, public, parameter :: RDR_X2Y = 12 integer, public, parameter :: RDR_X2Z = 13 integer, public, parameter :: RDR_Y2X = 21 integer, public, parameter :: RDR_Y2Z = 23 integer, public, parameter :: RDR_Z2X = 31 integer, public, parameter :: RDR_Z2Y = 32 integer, public, parameter :: POISSON_SOLVER_FFT = 0 integer, public, parameter :: POISSON_SOLVER_CG = 1 Derived Types type, public :: globs_t Components Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: nx_loc integer, public :: ny_loc integer, public :: nz_loc integer, public :: n_groups_x integer, public :: n_groups_y integer, public :: n_groups_z real(kind=dp), public :: Lx real(kind=dp), public :: Ly real(kind=dp), public :: Lz real(kind=dp), public :: dx real(kind=dp), public :: dy real(kind=dp), public :: dz real(kind=dp), public :: nu real(kind=dp), public :: dt integer, public :: n_iters integer, public :: n_output integer, public :: nproc_x = 1 integer, public :: nproc_y = 1 integer, public :: nproc_z = 1 character(len=20), public :: BC_x_s character(len=20), public :: BC_x_e character(len=20), public :: BC_y_s character(len=20), public :: BC_y_e character(len=20), public :: BC_z_s character(len=20), public :: BC_z_e integer, public :: poisson_solver_type Subroutines public  subroutine set_pprev_pnext (xprev, xnext, yprev, ynext, zprev, znext, xnproc, ynproc, znproc, nrank) Arguments Type Intent Optional Attributes Name integer, intent(out) :: xprev integer, intent(out) :: xnext integer, intent(out) :: yprev integer, intent(out) :: ynext integer, intent(out) :: zprev integer, intent(out) :: znext integer, intent(in) :: xnproc integer, intent(in) :: ynproc integer, intent(in) :: znproc integer, intent(in) :: nrank","tags":"","loc":"module/m_common.html"},{"title":"m_omp_exec_dist – x3d2","text":"Uses m_omp_common m_omp_sendrecv m_common m_tdsops m_omp_kernels_dist mpi Subroutines public  subroutine exec_dist_tds_compact (du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, n_block) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e type( tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_block public  subroutine exec_dist_transeq_compact (rhs, du, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, tdsops_du, tdsops_dud, tdsops_d2u, nu, nproc, pprev, pnext, n_block) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: rhs real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(out), dimension(:, :, :) :: dud real(kind=dp), intent(out), dimension(:, :, :) :: d2u real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: v real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_e type( tdsops_t ), intent(in) :: tdsops_du type( tdsops_t ), intent(in) :: tdsops_dud type( tdsops_t ), intent(in) :: tdsops_d2u real(kind=dp) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_block","tags":"","loc":"module/m_omp_exec_dist.html"},{"title":"m_solver – x3d2","text":"Uses m_time_integrator m_common m_allocator m_tdsops m_base_backend Interfaces public        interface solver_t public  function init (backend, time_integrator, xdirps, ydirps, zdirps, globs) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend class( time_intg_t ), intent(inout), target :: time_integrator class( dirps_t ), intent(inout), target :: xdirps class( dirps_t ), intent(inout), target :: ydirps class( dirps_t ), intent(inout), target :: zdirps class( globs_t ), intent(in) :: globs Return Value type( solver_t ) Abstract Interfaces abstract interface public  subroutine poisson_solver(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u Derived Types type, public :: solver_t solver class defines the Incompact3D algorithm at a very high level. Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public :: dt real(kind=dp), public :: nu integer, public :: n_iters integer, public :: n_output class( field_t ), public, pointer :: u class( field_t ), public, pointer :: v class( field_t ), public, pointer :: w class( base_backend_t ), public, pointer :: backend class( dirps_t ), public, pointer :: xdirps class( dirps_t ), public, pointer :: ydirps class( dirps_t ), public, pointer :: zdirps class( time_intg_t ), public, pointer :: time_integrator procedure( poisson_solver ), public, pointer :: poisson => null() Constructor public\n\n                    \n                    function init (backend, time_integrator, xdirps, ydirps, zdirps, globs) Type-Bound Procedures procedure, public :: transeq procedure, public :: divergence_v2p procedure, public :: gradient_p2v procedure, public :: curl procedure, public :: output procedure, public :: run Functions public  function init (backend, time_integrator, xdirps, ydirps, zdirps, globs) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend class( time_intg_t ), intent(inout), target :: time_integrator class( dirps_t ), intent(inout), target :: xdirps class( dirps_t ), intent(inout), target :: ydirps class( dirps_t ), intent(inout), target :: zdirps class( globs_t ), intent(in) :: globs Return Value type( solver_t ) Subroutines public  subroutine allocate_tdsops (dirps, nx, dx, backend) Arguments Type Intent Optional Attributes Name class( dirps_t ), intent(inout) :: dirps integer, intent(in) :: nx real(kind=dp), intent(in) :: dx class( base_backend_t ), intent(in) :: backend public  subroutine transeq (self, du, dv, dw, u, v, w) Skew-symmetric form of convection-diffusion terms in the\nincompressible Navier-Stokes momemtum equations, excluding\npressure terms.\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w public  subroutine divergence_v2p (self, div_u, u, v, w) Divergence of a vector field (u, v, w).\nInputs from velocity grid and outputs to pressure grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w public  subroutine gradient_p2v (self, dpdx, dpdy, dpdz, pressure) Gradient of a scalar field 'pressure'.\nInputs from pressure grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: pressure public  subroutine curl (self, o_i_hat, o_j_hat, o_k_hat, u, v, w) Curl of a vector field (u, v, w).\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w public  subroutine poisson_fft (self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u public  subroutine poisson_cg (self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u public  subroutine output (self, t, u_out) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: self real(kind=dp), intent(in) :: t real(kind=dp), intent(inout), dimension(:, :, :) :: u_out public  subroutine run (self, u_out, v_out, w_out) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: self real(kind=dp), intent(inout), dimension(:, :, :) :: u_out real(kind=dp), intent(inout), dimension(:, :, :) :: v_out real(kind=dp), intent(inout), dimension(:, :, :) :: w_out","tags":"","loc":"module/m_solver.html"},{"title":"m_tdsops – x3d2","text":"Uses iso_fortran_env m_common Interfaces public        interface tdsops_t public  function tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. 'n', 'delta', 'operation', and 'scheme' are necessary arguments.\nNumber of points 'n', distance between two points 'delta', the\n'operation' the tridiagonal system defines, and the 'scheme' that\nspecifies the exact scheme we choose to apply for the operation.\nThe remaining arguments are optional.\n'from_to' is necessary for interpolation and staggared derivative, and\nit can be 'v2p' or 'p2v'.\nIf the specific region the instance is operating is not a boundary\nregion, then 'bc_start' and 'bc_end' are either 'null' or not defined.\n'sym' is relevant when the boundary condition is free-slip. If sym is\n.true. then it means the field we operate on is assumed to be an even\nfunction (symmetric) accross the boundary. If it is .false. it means\nthat the field is assumed to be an odd function (anti-symmetric).\n'c_nu', 'nu0_nu' are relevant when operation is second order\nderivative and scheme is compact6-hyperviscous. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' character(len=*), intent(in), optional :: bc_start Boundary Cond. character(len=*), intent(in), optional :: bc_end Boundary Cond. logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function Derived Types type, public :: tdsops_t Tridiagonal Solver Operators class. Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha real(kind=dp), public :: a real(kind=dp), public :: b real(kind=dp), public :: c = 0._dp real(kind=dp), public :: d = 0._dp integer, public :: n integer, public :: n_halo Constructor public\n\n                    \n                    function tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Constructor function for the tdsops_t class. Read more… Type-Bound Procedures procedure, public :: preprocess procedure, public :: stagder_1st procedure, public :: interpl_mid procedure, public :: deriv_2nd procedure, public :: deriv_1st type, public :: dirps_t Directional tridiagonal solver container. Read more… Components Type Visibility Attributes Name Initial class( tdsops_t ), public, allocatable :: der1st class( tdsops_t ), public, allocatable :: der1st_sym class( tdsops_t ), public, allocatable :: der2nd class( tdsops_t ), public, allocatable :: der2nd_sym class( tdsops_t ), public, allocatable :: stagder_v2p class( tdsops_t ), public, allocatable :: stagder_p2v class( tdsops_t ), public, allocatable :: interpl_v2p class( tdsops_t ), public, allocatable :: interpl_p2v integer, public :: nrank integer, public :: nproc integer, public :: pnext integer, public :: pprev integer, public :: n integer, public :: n_blocks real(kind=dp), public :: L real(kind=dp), public :: d Functions public  function tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' character(len=*), intent(in), optional :: bc_start Boundary Cond. character(len=*), intent(in), optional :: bc_end Boundary Cond. logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function Subroutines public  subroutine deriv_1st (self, delta, scheme, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym public  subroutine deriv_2nd (self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu public  subroutine interpl_mid (self, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym public  subroutine stagder_1st (self, delta, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym public  subroutine preprocess (self, dist_b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b","tags":"","loc":"module/m_tdsops.html"},{"title":"m_time_integrator – x3d2","text":"Uses m_common m_allocator m_base_backend Interfaces public        interface time_intg_t public  function constructor (backend, allocator, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator integer, intent(in), optional :: nvars Return Value type( time_intg_t ) Derived Types type, public :: time_intg_t Components Type Visibility Attributes Name Initial integer, public :: istep integer, public :: nsteps integer, public :: nsubsteps integer, public :: order integer, public :: nvars integer, public :: nolds type( flist_t ), public, allocatable :: olds (:,:) class( base_backend_t ), public, pointer :: backend class( allocator_t ), public, pointer :: allocator Constructor public\n\n                    \n                    function constructor (backend, allocator, nvars) Type-Bound Procedures procedure, public :: step Functions public  function constructor (backend, allocator, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator integer, intent(in), optional :: nvars Return Value type( time_intg_t ) Subroutines public  subroutine step (self, u, v, w, du, dv, dw, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(in) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w class( field_t ), intent(in) :: du class( field_t ), intent(in) :: dv class( field_t ), intent(in) :: dw real(kind=dp), intent(in) :: dt public  subroutine adams_bashford_1st (vels, olds, coeffs) Arguments Type Intent Optional Attributes Name type( flist_t ) :: vels (:) type( flist_t ) :: olds (:) real :: coeffs (:)","tags":"","loc":"module/m_time_integrator.html"},{"title":"m_omp_sendrecv – x3d2","text":"Uses mpi m_common Subroutines public  subroutine sendrecv_fields (f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","loc":"module/m_omp_sendrecv.html"},{"title":"m_cuda_backend – x3d2","text":"Uses iso_fortran_env m_cuda_allocator m_cuda_exec_dist m_common cudafor m_tdsops m_cuda_sendrecv m_cuda_poisson_fft m_allocator m_cuda_common m_cuda_kernels_dist mpi m_poisson_fft m_cuda_kernels_reorder m_base_backend m_cuda_tdsops Interfaces public        interface cuda_backend_t public  function init (globs, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( globs_t ) :: globs class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t ) Derived Types type, public, extends( base_backend_t ) :: cuda_backend_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu integer, public :: nx_loc integer, public :: ny_loc integer, public :: nz_loc class( allocator_t ), public, pointer :: allocator class( dirps_t ), public, pointer :: xdirps class( dirps_t ), public, pointer :: ydirps class( dirps_t ), public, pointer :: zdirps class( poisson_fft_t ), public, pointer :: poisson_fft integer, public :: MPI_FP_PREC = dp real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_e_dev type(dim3), public :: xblocks type(dim3), public :: xthreads type(dim3), public :: yblocks type(dim3), public :: ythreads type(dim3), public :: zblocks type(dim3), public :: zthreads Constructor public\n\n                    \n                    function init (globs, allocator) Type-Bound Procedures procedure, public :: alloc_tdsops => alloc_cuda_tdsops procedure, public :: transeq_x => transeq_x_cuda procedure, public :: transeq_y => transeq_y_cuda procedure, public :: transeq_z => transeq_z_cuda procedure, public :: tds_solve => tds_solve_cuda procedure, public :: reorder => reorder_cuda procedure, public :: sum_yintox => sum_yintox_cuda procedure, public :: sum_zintox => sum_zintox_cuda procedure, public :: vecadd => vecadd_cuda procedure, public :: scalar_product => scalar_product_cuda procedure, public :: set_field => set_field_cuda procedure, public :: get_field => get_field_cuda procedure, public :: init_poisson_fft => init_cuda_poisson_fft procedure, public :: transeq_cuda_dist procedure, public :: transeq_cuda_thom procedure, public :: tds_solve_dist Functions public  function init (globs, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( globs_t ) :: globs class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t ) public  function scalar_product_cuda (self, x, y) result(s) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) Subroutines public  subroutine alloc_cuda_tdsops (self, tdsops, n, dx, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n real(kind=dp), intent(in) :: dx character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu public  subroutine transeq_x_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_y_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_z_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_cuda_dist (self, du, dv, dw, u, v, w, dirps, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads public  subroutine transeq_cuda_thom (self, du, dv, dw, u, v, w, dirps) Thomas algorithm implementation. So much more easier than the\ndistributed algorithm. It is intended to work only on a single rank\nso there is no MPI communication. Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine tds_solve_cuda (self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops public  subroutine tds_solve_dist (self, du, u, dirps, tdsops, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads public  subroutine reorder_cuda (self, u_o, u_i, direction) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u_o class( field_t ), intent(in) :: u_i integer, intent(in) :: direction public  subroutine sum_yintox_cuda (self, u, u_y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_y public  subroutine sum_zintox_cuda (self, u, u_z) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_z public  subroutine vecadd_cuda (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y public  subroutine copy_into_buffers (u_send_s_dev, u_send_e_dev, u_dev, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_s_dev real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_e_dev real(kind=dp), intent(in), device, dimension(:, :, :) :: u_dev integer, intent(in) :: n public  subroutine set_field_cuda (self, f, arr) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: arr public  subroutine get_field_cuda (self, arr, f) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: arr class( field_t ), intent(in) :: f public  subroutine init_cuda_poisson_fft (self, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"module/m_cuda_backend.html"},{"title":"xcompact – x3d2","text":"Uses m_omp_backend m_solver m_time_integrator m_cuda_allocator m_omp_common m_common m_tdsops m_allocator m_cuda_backend m_cuda_common mpi m_base_backend m_cuda_tdsops Variables Type Attributes Name Initial type( globs_t ) :: globs class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator type( solver_t ) :: solver type( time_intg_t ) :: time_integrator type( dirps_t ) :: xdirps type( dirps_t ) :: ydirps type( dirps_t ) :: zdirps type( cuda_backend_t ), target :: cuda_backend type( cuda_allocator_t ), target :: cuda_allocator integer :: ndevs integer :: devnum type( omp_backend_t ), target :: omp_backend type( allocator_t ), target :: omp_allocator real(kind=dp), allocatable, dimension(:, :, :) :: u real(kind=dp), allocatable, dimension(:, :, :) :: v real(kind=dp), allocatable, dimension(:, :, :) :: w real(kind=dp) :: t_start real(kind=dp) :: t_end integer :: nrank integer :: nproc integer :: ierr","tags":"","loc":"program/xcompact.html"},{"title":"backend.f90 – x3d2","text":"Source Code module m_omp_backend use m_allocator , only : allocator_t , field_t use m_base_backend , only : base_backend_t use m_common , only : dp , globs_t use m_tdsops , only : dirps_t , tdsops_t use m_omp_exec_dist , only : exec_dist_tds_compact , exec_dist_transeq_compact use m_omp_sendrecv , only : sendrecv_fields use m_omp_common , only : SZ use m_omp_poisson_fft , only : omp_poisson_fft_t implicit none type , extends ( base_backend_t ) :: omp_backend_t !character(len=*), parameter :: name = 'omp' integer :: MPI_FP_PREC = dp real ( dp ), allocatable , dimension (:, :, :) :: & u_recv_s , u_recv_e , u_send_s , u_send_e , & v_recv_s , v_recv_e , v_send_s , v_send_e , & w_recv_s , w_recv_e , w_send_s , w_send_e , & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e contains procedure :: alloc_tdsops => alloc_omp_tdsops procedure :: transeq_x => transeq_x_omp procedure :: transeq_y => transeq_y_omp procedure :: transeq_z => transeq_z_omp procedure :: tds_solve => tds_solve_omp procedure :: reorder => reorder_omp procedure :: sum_yintox => sum_yintox_omp procedure :: sum_zintox => sum_zintox_omp procedure :: vecadd => vecadd_omp procedure :: scalar_product => scalar_product_omp procedure :: set_field => set_field_omp procedure :: get_field => get_field_omp procedure :: init_poisson_fft => init_omp_poisson_fft procedure :: transeq_omp_dist end type omp_backend_t interface omp_backend_t module procedure init end interface omp_backend_t contains function init ( globs , allocator ) result ( backend ) implicit none class ( globs_t ) :: globs class ( allocator_t ), target , intent ( inout ) :: allocator type ( omp_backend_t ) :: backend integer :: n_halo , n_block select type ( allocator ) type is ( allocator_t ) ! class level access to the allocator backend % allocator => allocator end select n_halo = 4 n_block = globs % n_groups_x allocate ( backend % u_send_s ( SZ , n_halo , n_block )) allocate ( backend % u_send_e ( SZ , n_halo , n_block )) allocate ( backend % u_recv_s ( SZ , n_halo , n_block )) allocate ( backend % u_recv_e ( SZ , n_halo , n_block )) allocate ( backend % v_send_s ( SZ , n_halo , n_block )) allocate ( backend % v_send_e ( SZ , n_halo , n_block )) allocate ( backend % v_recv_s ( SZ , n_halo , n_block )) allocate ( backend % v_recv_e ( SZ , n_halo , n_block )) allocate ( backend % w_send_s ( SZ , n_halo , n_block )) allocate ( backend % w_send_e ( SZ , n_halo , n_block )) allocate ( backend % w_recv_s ( SZ , n_halo , n_block )) allocate ( backend % w_recv_e ( SZ , n_halo , n_block )) allocate ( backend % du_send_s ( SZ , 1 , n_block )) allocate ( backend % du_send_e ( SZ , 1 , n_block )) allocate ( backend % du_recv_s ( SZ , 1 , n_block )) allocate ( backend % du_recv_e ( SZ , 1 , n_block )) allocate ( backend % dud_send_s ( SZ , 1 , n_block )) allocate ( backend % dud_send_e ( SZ , 1 , n_block )) allocate ( backend % dud_recv_s ( SZ , 1 , n_block )) allocate ( backend % dud_recv_e ( SZ , 1 , n_block )) allocate ( backend % d2u_send_s ( SZ , 1 , n_block )) allocate ( backend % d2u_send_e ( SZ , 1 , n_block )) allocate ( backend % d2u_recv_s ( SZ , 1 , n_block )) allocate ( backend % d2u_recv_e ( SZ , 1 , n_block )) end function init subroutine alloc_omp_tdsops ( & self , tdsops , n , dx , operation , scheme , & n_halo , from_to , bc_start , bc_end , sym , c_nu , nu0_nu & ) implicit none class ( omp_backend_t ) :: self class ( tdsops_t ), allocatable , intent ( inout ) :: tdsops integer , intent ( in ) :: n real ( dp ), intent ( in ) :: dx character ( * ), intent ( in ) :: operation , scheme integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to , bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu allocate ( tdsops_t :: tdsops ) select type ( tdsops ) type is ( tdsops_t ) tdsops = tdsops_t ( n , dx , operation , scheme , n_halo , from_to , & bc_start , bc_end , sym , c_nu , nu0_nu ) end select end subroutine alloc_omp_tdsops subroutine transeq_x_omp ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps call self % transeq_omp_dist ( du , dv , dw , u , v , w , dirps ) end subroutine transeq_x_omp subroutine transeq_y_omp ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass v, u, w call self % transeq_omp_dist ( dv , du , dw , v , u , w , dirps ) end subroutine transeq_y_omp subroutine transeq_z_omp ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass w, u, v call self % transeq_omp_dist ( dw , du , dv , w , u , v , dirps ) end subroutine transeq_z_omp subroutine transeq_omp_dist ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps call transeq_halo_exchange ( self , u , v , w , dirps ) call transeq_dist_component ( self , du , u , u , & dirps % der1st , dirps % der1st_sym , dirps % der2nd , dirps ) call transeq_dist_component ( self , dv , v , u , & dirps % der1st_sym , dirps % der1st , dirps % der2nd_sym , dirps ) call transeq_dist_component ( self , dw , w , u , & dirps % der1st_sym , dirps % der1st , dirps % der2nd_sym , dirps ) end subroutine transeq_omp_dist subroutine transeq_halo_exchange ( self , u , v , w , dirps ) class ( omp_backend_t ) :: self class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps integer :: n_halo ! TODO: don't hardcode n_halo n_halo = 4 call copy_into_buffers ( self % u_send_s , self % u_send_e , u % data , dirps % n , dirps % n_blocks ) call copy_into_buffers ( self % v_send_s , self % v_send_e , v % data , dirps % n , dirps % n_blocks ) call copy_into_buffers ( self % w_send_s , self % w_send_e , w % data , dirps % n , dirps % n_blocks ) call sendrecv_fields ( self % u_recv_s , self % u_recv_e , self % u_send_s , self % u_send_e , & SZ * n_halo * dirps % n_blocks , dirps % nproc , dirps % pprev , dirps % pnext ) call sendrecv_fields ( self % v_recv_s , self % v_recv_e , self % v_send_s , self % v_send_e , & SZ * n_halo * dirps % n_blocks , dirps % nproc , dirps % pprev , dirps % pnext ) call sendrecv_fields ( self % w_recv_s , self % w_recv_e , self % w_send_s , self % w_send_e , & SZ * n_halo * dirps % n_blocks , dirps % nproc , dirps % pprev , dirps % pnext ) end subroutine transeq_halo_exchange !> Computes RHS_x&#94;v following: ! rhs_x&#94;v = -0.5*(u*dv/dx + duv/dx) + nu*d2v/dx2 subroutine transeq_dist_component ( self , rhs , v , u , tdsops_du , tdsops_dud , tdsops_d2u , dirps ) class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: rhs class ( field_t ), intent ( in ) :: u , v class ( tdsops_t ), intent ( in ) :: tdsops_du class ( tdsops_t ), intent ( in ) :: tdsops_dud class ( tdsops_t ), intent ( in ) :: tdsops_d2u type ( dirps_t ), intent ( in ) :: dirps class ( field_t ), pointer :: du , d2u , dud du => self % allocator % get_block () dud => self % allocator % get_block () d2u => self % allocator % get_block () call exec_dist_transeq_compact (& rhs % data , du % data , dud % data , d2u % data , & self % du_send_s , self % du_send_e , self % du_recv_s , self % du_recv_e , & self % dud_send_s , self % dud_send_e , self % dud_recv_s , self % dud_recv_e , & self % d2u_send_s , self % d2u_send_e , self % d2u_recv_s , self % d2u_recv_e , & u % data , self % u_recv_s , self % u_recv_e , & v % data , self % v_recv_s , self % v_recv_e , & tdsops_du , tdsops_dud , tdsops_d2u , self % nu , & dirps % nproc , dirps % pprev , dirps % pnext , dirps % n_blocks ) call self % allocator % release_block ( du ) call self % allocator % release_block ( dud ) call self % allocator % release_block ( d2u ) end subroutine transeq_dist_component subroutine tds_solve_omp ( self , du , u , dirps , tdsops ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u type ( dirps_t ), intent ( in ) :: dirps class ( tdsops_t ), intent ( in ) :: tdsops call tds_solve_dist ( self , du , u , dirps , tdsops ) end subroutine tds_solve_omp subroutine tds_solve_dist ( self , du , u , dirps , tdsops ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u type ( dirps_t ), intent ( in ) :: dirps class ( tdsops_t ), intent ( in ) :: tdsops integer :: n_halo ! TODO: don't hardcode n_halo n_halo = 4 call copy_into_buffers ( self % u_send_s , self % u_send_e , u % data , dirps % n , dirps % n_blocks ) ! halo exchange call sendrecv_fields ( self % u_recv_s , self % u_recv_e , self % u_send_s , self % u_send_e , & SZ * n_halo * dirps % n_blocks , dirps % nproc , dirps % pprev , dirps % pnext ) call exec_dist_tds_compact ( & du % data , u % data , self % u_recv_s , self % u_recv_e , self % du_send_s , self % du_send_e , & self % du_recv_s , self % du_recv_e , & tdsops , dirps % nproc , dirps % pprev , dirps % pnext , dirps % n_blocks ) end subroutine tds_solve_dist subroutine reorder_omp ( self , u_ , u , direction ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: u_ class ( field_t ), intent ( in ) :: u integer , intent ( in ) :: direction end subroutine reorder_omp subroutine sum_yintox_omp ( self , u , u_ ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_ end subroutine sum_yintox_omp subroutine sum_zintox_omp ( self , u , u_ ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_ end subroutine sum_zintox_omp subroutine vecadd_omp ( self , a , x , b , y ) implicit none class ( omp_backend_t ) :: self real ( dp ), intent ( in ) :: a class ( field_t ), intent ( in ) :: x real ( dp ), intent ( in ) :: b class ( field_t ), intent ( inout ) :: y end subroutine vecadd_omp real ( dp ) function scalar_product_omp ( self , x , y ) result ( s ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( in ) :: x , y s = 0._dp end function scalar_product_omp subroutine copy_into_buffers ( u_send_s , u_send_e , u , n , n_blocks ) implicit none real ( dp ), dimension (:, :, :), intent ( out ) :: u_send_s , u_send_e real ( dp ), dimension (:, :, :), intent ( in ) :: u integer , intent ( in ) :: n integer , intent ( in ) :: n_blocks integer :: i , j , k integer :: n_halo = 4 !$omp parallel do do k = 1 , n_blocks do j = 1 , n_halo !$omp simd do i = 1 , SZ u_send_s ( i , j , k ) = u ( i , j , k ) u_send_e ( i , j , k ) = u ( i , n - n_halo + j , k ) end do !$omp end simd end do end do !$omp end parallel do end subroutine copy_into_buffers subroutine set_field_omp ( self , f , arr ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), dimension (:, :, :), intent ( in ) :: arr f % data = arr end subroutine set_field_omp subroutine get_field_omp ( self , arr , f ) implicit none class ( omp_backend_t ) :: self real ( dp ), dimension (:, :, :), intent ( out ) :: arr class ( field_t ), intent ( in ) :: f arr = f % data end subroutine get_field_omp subroutine init_omp_poisson_fft ( self , xdirps , ydirps , zdirps ) implicit none class ( omp_backend_t ) :: self type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps allocate ( omp_poisson_fft_t :: self % poisson_fft ) select type ( poisson_fft => self % poisson_fft ) type is ( omp_poisson_fft_t ) poisson_fft = omp_poisson_fft_t ( xdirps , ydirps , zdirps ) end select end subroutine init_omp_poisson_fft end module m_omp_backend","tags":"","loc":"sourcefile/backend.f90.html"},{"title":"allocator.f90 – x3d2","text":"Source Code module m_cuda_allocator use m_allocator , only : allocator_t , field_t use m_common , only : dp implicit none type , extends ( allocator_t ) :: cuda_allocator_t contains procedure :: create_block => create_cuda_block end type cuda_allocator_t type , extends ( field_t ) :: cuda_field_t real ( dp ), allocatable , device :: data_d (:, :, :) end type cuda_field_t interface cuda_field_t module procedure cuda_field_constructor end interface cuda_field_t contains function cuda_field_constructor ( dims , next , id ) result ( m ) integer , intent ( in ) :: dims ( 3 ), id type ( cuda_field_t ), pointer , intent ( in ) :: next type ( cuda_field_t ) :: m allocate ( m % data_d ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) m % refcount = 0 m % next => next m % id = id end function cuda_field_constructor function create_cuda_block ( self , next ) result ( ptr ) class ( cuda_allocator_t ), intent ( inout ) :: self type ( cuda_field_t ), pointer , intent ( in ) :: next type ( cuda_field_t ), pointer :: newblock class ( field_t ), pointer :: ptr allocate ( newblock ) self % next_id = self % next_id + 1 newblock = cuda_field_t ( self % dims , next , id = self % next_id ) ptr => newblock end function create_cuda_block end module m_cuda_allocator","tags":"","loc":"sourcefile/allocator.f90.html"},{"title":"complex.f90 – x3d2","text":"Source Code module m_cuda_complex use cudafor use m_common , only : dp use m_cuda_common , only : SZ implicit none contains attributes ( global ) subroutine process_spectral_div_u ( & div , waves , nx , ny , nz , ax , bx , ay , by , az , bz & ) implicit none ! Arguments complex ( dp ), device , intent ( inout ), dimension (:, :, :) :: div complex ( dp ), device , intent ( in ), dimension (:, :, :) :: waves real ( dp ), device , intent ( in ), dimension (:) :: ax , bx , ay , by , az , bz integer , value , intent ( in ) :: nx , ny , nz ! Local variables integer :: i , j , b , ix , iy , iz real ( dp ) :: tmp_r , tmp_c , div_r , div_c i = threadIdx % x b = blockIdx % x do j = 1 , nx ! normalisation div_r = real ( div ( i , j , b ), kind = dp ) / ( nx * ny * nz ) div_c = aimag ( div ( i , j , b )) / ( nx * ny * nz ) ! get the indices for x, y, z directions ix = j ; iy = i + ( b - 1 ) / ( nz / 2 + 1 ) * SZ ; iz = mod ( b - 1 , nz / 2 + 1 ) + 1 ! post-process forward ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) + tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) - tmp_r * az ( iz ) ! post-process in y tmp_r = div_r tmp_c = div_c div_r = tmp_r * by ( iy ) + tmp_c * ay ( iy ) div_c = tmp_c * by ( iy ) - tmp_r * ay ( iy ) if ( iy > ny / 2 + 1 ) div_r = - div_r if ( iy > ny / 2 + 1 ) div_c = - div_c ! post-process in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) + tmp_c * ax ( ix ) div_c = tmp_c * bx ( ix ) - tmp_r * ax ( ix ) if ( ix > nx / 2 + 1 ) div_r = - div_r if ( ix > nx / 2 + 1 ) div_c = - div_c ! Solve Poisson tmp_r = real ( waves ( i , j , b ), kind = dp ) tmp_c = aimag ( waves ( i , j , b )) if (( tmp_r < 1.e-16_dp ) . or . ( tmp_c < 1.e-16_dp )) then div_r = 0._dp ; div_c = 0._dp else div_r = - div_r / tmp_r div_c = - div_c / tmp_c end if ! post-process backward ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) - tmp_c * az ( iz ) div_c = - tmp_c * bz ( iz ) - tmp_r * az ( iz ) ! post-process in y tmp_r = div_r tmp_c = div_c div_r = tmp_r * by ( iy ) + tmp_c * ay ( iy ) div_c = tmp_c * by ( iy ) - tmp_r * ay ( iy ) if ( iy > ny / 2 + 1 ) div_r = - div_r if ( iy > ny / 2 + 1 ) div_c = - div_c ! post-process in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) + tmp_c * ax ( ix ) div_c = - tmp_c * bx ( ix ) + tmp_r * ax ( ix ) if ( ix > nx / 2 + 1 ) div_r = - div_r if ( ix > nx / 2 + 1 ) div_c = - div_c ! update the entry div ( i , j , b ) = cmplx ( div_r , div_c , kind = dp ) end do end subroutine process_spectral_div_u attributes ( global ) subroutine reorder_cmplx_x2y_T ( u_y , u_x , nz ) implicit none complex ( dp ), device , intent ( out ), dimension (:, :, :) :: u_y complex ( dp ), device , intent ( in ), dimension (:, :, :) :: u_x integer , value , intent ( in ) :: nz complex ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_x (( b_i - 1 ) * SZ + j , i , b_k + nz * ( b_j - 1 )) call syncthreads () ! copy into output array from shared u_y (( b_j - 1 ) * SZ + j , i , ( b_i - 1 ) * nz + b_k ) = tile ( j , i ) end subroutine reorder_cmplx_x2y_T attributes ( global ) subroutine reorder_cmplx_y2x_T ( u_x , u_y , nz ) implicit none complex ( dp ), device , intent ( out ), dimension (:, :, :) :: u_x complex ( dp ), device , intent ( in ), dimension (:, :, :) :: u_y integer , value , intent ( in ) :: nz complex ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_y (( b_j - 1 ) * SZ + j , i , b_k + nz * ( b_i - 1 )) call syncthreads () ! copy into output array from shared u_x (( b_i - 1 ) * SZ + j , i , ( b_j - 1 ) * nz + b_k ) = tile ( j , i ) end subroutine reorder_cmplx_y2x_T attributes ( global ) subroutine reorder_cmplx_y2z_T ( u_z , u_y , nx , nz ) implicit none complex ( dp ), device , intent ( out ), dimension (:, :, :) :: u_z complex ( dp ), device , intent ( in ), dimension (:, :, :) :: u_y integer , value , intent ( in ) :: nx , nz complex ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , k , b_i , b_j , b_k , b_x , b_y , b_z i = threadIdx % x j = threadIdx % y k = threadIdx % z b_x = blockIdx % z b_y = blockIdx % y b_z = blockIdx % x ! copy into shared if ( j + ( b_z - 1 ) * SZ <= nz ) & tile ( i , j ) = u_y ( i + ( b_y - 1 ) * SZ , mod ( b_x - 1 , SZ ) + 1 , & j + ( b_z - 1 ) * SZ + (( b_x - 1 ) / SZ ) * nz ) call syncthreads () ! copy into output array from shared if ( i + ( b_z - 1 ) * SZ <= nz ) & u_z ( i + ( b_z - 1 ) * SZ , j , b_x + ( b_y - 1 ) * nx ) = tile ( j , i ) end subroutine reorder_cmplx_y2z_T attributes ( global ) subroutine reorder_cmplx_z2y_T ( u_y , u_z , nx , nz ) implicit none complex ( dp ), device , intent ( out ), dimension (:, :, :) :: u_y complex ( dp ), device , intent ( in ), dimension (:, :, :) :: u_z integer , value , intent ( in ) :: nx , nz complex ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , k , b_x , b_y , b_z i = threadIdx % x j = threadIdx % y k = threadIdx % z b_x = blockIdx % z b_y = blockIdx % y b_z = blockIdx % x ! copy into shared if ( i + ( b_z - 1 ) * SZ <= nz ) & tile ( i , j ) = u_z ( i + ( b_z - 1 ) * SZ , j , b_x + ( b_y - 1 ) * nx ) call syncthreads () ! copy into output array from shared if ( j + ( b_z - 1 ) * SZ <= nz ) & u_y ( i + ( b_y - 1 ) * SZ , mod ( b_x - 1 , SZ ) + 1 , & j + ( b_z - 1 ) * SZ + (( b_x - 1 ) / SZ ) * nz ) = tile ( j , i ) end subroutine reorder_cmplx_z2y_T attributes ( global ) subroutine reshapeDSF ( uout , uin ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: uout real ( dp ), device , intent ( in ), dimension (:, :, :) :: uin real ( dp ), shared :: tile ( SZ + 1 , SZ ) integer :: i , j , b_i , b i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b = blockIdx % y tile ( i , j ) = uin ( i , j + ( b_i - 1 ) * SZ , b ) call syncthreads () uout ( i + ( b_i - 1 ) * SZ , j , b ) = tile ( j , i ) end subroutine reshapeDSF attributes ( global ) subroutine reshapeDSB ( uout , uin ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: uout real ( dp ), device , intent ( in ), dimension (:, :, :) :: uin real ( dp ), shared :: tile ( SZ + 1 , SZ ) integer :: i , j , b_i , b i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b = blockIdx % y tile ( i , j ) = uin ( i + ( b_i - 1 ) * SZ , j , b ) call syncthreads () uout ( i , j + ( b_i - 1 ) * SZ , b ) = tile ( j , i ) end subroutine reshapeDSB attributes ( global ) subroutine reshapeCDSF ( uout , uin ) implicit none complex ( dp ), device , intent ( out ), dimension (:, :, :) :: uout complex ( dp ), device , intent ( in ), dimension (:, :, :) :: uin complex ( dp ), shared :: tile ( SZ + 1 , SZ ) integer :: i , j , b_i , b i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b = blockIdx % y tile ( i , j ) = uin ( i , j + ( b_i - 1 ) * SZ , b ) call syncthreads () uout ( i + ( b_i - 1 ) * SZ , j , b ) = tile ( j , i ) end subroutine reshapeCDSF attributes ( global ) subroutine reshapeCDSB ( uout , uin ) implicit none complex ( dp ), device , intent ( out ), dimension (:, :, :) :: uout complex ( dp ), device , intent ( in ), dimension (:, :, :) :: uin complex ( dp ), shared :: tile ( SZ + 1 , SZ ) integer :: i , j , b_i , b i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b = blockIdx % y tile ( i , j ) = uin ( i + ( b_i - 1 ) * SZ , j , b ) call syncthreads () uout ( i , j + ( b_i - 1 ) * SZ , b ) = tile ( j , i ) end subroutine reshapeCDSB end module m_cuda_complex","tags":"","loc":"sourcefile/complex.f90.html"},{"title":"backend.f90 – x3d2","text":"Source Code module m_base_backend use m_allocator , only : allocator_t , field_t use m_common , only : dp use m_poisson_fft , only : poisson_fft_t use m_tdsops , only : tdsops_t , dirps_t implicit none type , abstract :: base_backend_t !! base_backend class defines all the abstract operations that the !! solver class requires. !! !! For example, transport equation in solver class evaluates the !! derivatives in x, y, and z directions, and reorders the input !! fields as required. Then finally, combines all the directional !! derivatives to obtain the divergence of U*. !! !! All these high level operations solver class executes are !! defined here using the abstract interfaces. Every backend !! implementation extends the present abstact backend class to !! define the specifics of these operations based on the target !! architecture. real ( dp ) :: nu integer :: nx_loc , ny_loc , nz_loc class ( allocator_t ), pointer :: allocator class ( dirps_t ), pointer :: xdirps , ydirps , zdirps class ( poisson_fft_t ), pointer :: poisson_fft contains procedure ( transeq_ders ), deferred :: transeq_x procedure ( transeq_ders ), deferred :: transeq_y procedure ( transeq_ders ), deferred :: transeq_z procedure ( tds_solve ), deferred :: tds_solve procedure ( reorder ), deferred :: reorder procedure ( sum_intox ), deferred :: sum_yintox procedure ( sum_intox ), deferred :: sum_zintox procedure ( vecadd ), deferred :: vecadd procedure ( scalar_product ), deferred :: scalar_product procedure ( get_field ), deferred :: get_field procedure ( set_field ), deferred :: set_field procedure ( alloc_tdsops ), deferred :: alloc_tdsops procedure ( init_poisson_fft ), deferred :: init_poisson_fft end type base_backend_t abstract interface subroutine transeq_ders ( self , du , dv , dw , u , v , w , dirps ) !! transeq equation obtains the derivatives direction by !! direction, and the exact algorithm used to obtain these !! derivatives are decided at runtime. Backend implementations !! are responsible from directing calls to transeq_ders into !! the correct algorithm. import :: base_backend_t import :: field_t import :: dirps_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps end subroutine transeq_ders end interface abstract interface subroutine tds_solve ( self , du , u , dirps , tdsops ) !! transeq equation obtains the derivatives direction by !! direction, and the exact algorithm used to obtain these !! derivatives are decided at runtime. Backend implementations !! are responsible from directing calls to transeq_ders into !! the correct algorithm. import :: base_backend_t import :: field_t import :: dirps_t import :: tdsops_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u type ( dirps_t ), intent ( in ) :: dirps class ( tdsops_t ), intent ( in ) :: tdsops end subroutine tds_solve end interface abstract interface subroutine reorder ( self , u_ , u , direction ) !! reorder subroutines are straightforward, they rearrange !! data into our specialist data structure so that regardless !! of the direction tridiagonal systems are solved efficiently !! and fast. import :: base_backend_t import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: u_ class ( field_t ), intent ( in ) :: u integer , intent ( in ) :: direction end subroutine reorder end interface abstract interface subroutine sum_intox ( self , u , u_ ) !! sum9into3 subroutine combines all the directional velocity !! derivatives into the corresponding x directional fields. import :: base_backend_t import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_ end subroutine sum_intox end interface abstract interface subroutine vecadd ( self , a , x , b , y ) !! adds two vectors together: y = a*x + b*y import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self real ( dp ), intent ( in ) :: a class ( field_t ), intent ( in ) :: x real ( dp ), intent ( in ) :: b class ( field_t ), intent ( inout ) :: y end subroutine vecadd end interface abstract interface real ( dp ) function scalar_product ( self , x , y ) result ( s ) !! Calculates the scalar product of two input fields import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( in ) :: x , y end function scalar_product end interface abstract interface subroutine get_field ( self , arr , f ) !! copy the specialist data structure from device or host back !! to a regular 3D data structure. import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self real ( dp ), dimension (:, :, :), intent ( out ) :: arr class ( field_t ), intent ( in ) :: f end subroutine get_field subroutine set_field ( self , f , arr ) !! copy the initial condition stored in a regular 3D data !! structure into the specialist data structure array on the !! device or host. import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), dimension (:, :, :), intent ( in ) :: arr end subroutine set_field end interface abstract interface subroutine alloc_tdsops ( self , tdsops , n , dx , operation , scheme , n_halo , & from_to , bc_start , bc_end , sym , c_nu , nu0_nu ) import :: base_backend_t import :: dp import :: tdsops_t implicit none class ( base_backend_t ) :: self class ( tdsops_t ), allocatable , intent ( inout ) :: tdsops integer , intent ( in ) :: n real ( dp ), intent ( in ) :: dx character ( * ), intent ( in ) :: operation , scheme integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to , bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu end subroutine alloc_tdsops end interface abstract interface subroutine init_poisson_fft ( self , xdirps , ydirps , zdirps ) import :: base_backend_t import :: dirps_t implicit none class ( base_backend_t ) :: self type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps end subroutine init_poisson_fft end interface end module m_base_backend","tags":"","loc":"sourcefile/backend.f90~2.html"},{"title":"poisson_fft.f90 – x3d2","text":"Source Code module m_omp_poisson_fft use m_allocator , only : field_t use m_common , only : dp use m_poisson_fft , only : poisson_fft_t use m_tdsops , only : dirps_t use m_omp_common , only : SZ implicit none type , extends ( poisson_fft_t ) :: omp_poisson_fft_t !! FFT based Poisson solver !! It can only handle 1D decompositions along z direction. complex ( dp ), allocatable , dimension (:, :, :) :: c_x , c_y , c_z contains procedure :: fft_forward => fft_forward_omp procedure :: fft_backward => fft_backward_omp procedure :: fft_postprocess => fft_postprocess_omp end type omp_poisson_fft_t interface omp_poisson_fft_t module procedure init end interface omp_poisson_fft_t private :: init contains function init ( xdirps , ydirps , zdirps ) result ( poisson_fft ) implicit none class ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps type ( omp_poisson_fft_t ) :: poisson_fft call poisson_fft % base_init ( xdirps , ydirps , zdirps , SZ ) end function init subroutine fft_forward_omp ( self , f_in ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f_in end subroutine fft_forward_omp subroutine fft_backward_omp ( self , f_out ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out end subroutine fft_backward_omp subroutine fft_postprocess_omp ( self ) implicit none class ( omp_poisson_fft_t ) :: self end subroutine fft_postprocess_omp end module m_omp_poisson_fft","tags":"","loc":"sourcefile/poisson_fft.f90.html"},{"title":"poisson_fft.f90 – x3d2","text":"Source Code module m_poisson_fft use m_allocator , only : field_t use m_common , only : dp , pi use m_tdsops , only : dirps_t implicit none type , abstract :: poisson_fft_t !! FFT based Poisson solver !! It can only handle 1D decompositions along z direction. integer :: nx , ny , nz complex ( dp ), allocatable , dimension (:, :, :) :: waves complex ( dp ), allocatable , dimension (:) :: ax , bx , ay , by , az , bz contains procedure ( fft_forward ), deferred :: fft_forward procedure ( fft_backward ), deferred :: fft_backward procedure ( fft_postprocess ), deferred :: fft_postprocess procedure :: base_init procedure :: waves_set end type poisson_fft_t abstract interface subroutine fft_forward ( self , f_in ) import :: poisson_fft_t import :: field_t implicit none class ( poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f_in end subroutine fft_forward subroutine fft_backward ( self , f_out ) import :: poisson_fft_t import :: field_t implicit none class ( poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out end subroutine fft_backward subroutine fft_postprocess ( self ) import :: poisson_fft_t implicit none class ( poisson_fft_t ) :: self end subroutine fft_postprocess end interface contains subroutine base_init ( self , xdirps , ydirps , zdirps , sz ) implicit none class ( poisson_fft_t ) :: self class ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps integer , intent ( in ) :: sz self % nx = xdirps % n ; self % ny = ydirps % n ; self % nz = zdirps % n allocate ( self % ax ( self % nx ), self % bx ( self % nx )) allocate ( self % ay ( self % nx ), self % by ( self % nx )) allocate ( self % az ( self % nx ), self % bz ( self % nx )) allocate ( self % waves ( sz , self % nx , ( self % ny * ( self % nz / 2 + 1 )) / sz )) ! waves_set requires some of the preprocessed tdsops variables. call self % waves_set ( xdirps , ydirps , zdirps , sz ) end subroutine base_init subroutine waves_set ( self , xdirps , ydirps , zdirps , sz ) !! Ref. JCP 228 (2009), 5989–6015, Sec 4 implicit none class ( poisson_fft_t ) :: self type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps integer , intent ( in ) :: sz complex ( dp ), allocatable , dimension (:) :: xkx , xk2 , yky , yk2 , zkz , zk2 , & exs , eys , ezs integer :: nx , ny , nz real ( dp ) :: w , wp , rlexs , rleys , rlezs , xtt , ytt , ztt , xt1 , yt1 , zt1 complex ( dp ) :: xt2 , yt2 , zt2 , xyzk integer :: i , j , ka , kb , ix , iy , iz nx = xdirps % n ; ny = ydirps % n ; nz = zdirps % n do i = 1 , nx self % ax ( i ) = sin (( i - 1 ) * pi / nx ) self % bx ( i ) = cos (( i - 1 ) * pi / nx ) end do do i = 1 , ny self % ay ( i ) = sin (( i - 1 ) * pi / ny ) self % by ( i ) = cos (( i - 1 ) * pi / ny ) end do do i = 1 , nz self % az ( i ) = sin (( i - 1 ) * pi / nz ) self % bz ( i ) = cos (( i - 1 ) * pi / nz ) end do ! Now kxyz allocate ( xkx ( nx ), xk2 ( nx ), exs ( nx )) allocate ( yky ( ny ), yk2 ( ny ), eys ( ny )) allocate ( zkz ( nz ), zk2 ( nz ), ezs ( nz )) xkx (:) = 0 ; xk2 (:) = 0 ; yky (:) = 0 ; yk2 (:) = 0 ; zkz (:) = 0 ; zk2 (:) = 0 ! periodic-x do i = 1 , nx / 2 + 1 w = 2 * pi * ( i - 1 ) / nx wp = xdirps % stagder_v2p % a * 2 * xdirps % d * sin ( 0.5_dp * w ) & + xdirps % stagder_v2p % b * 2 * xdirps % d * sin ( 1.5_dp * w ) wp = wp / ( 1._dp + 2 * xdirps % stagder_v2p % alpha * cos ( w )) xkx ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nx * wp / xdirps % L ) exs ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nx * w / xdirps % L ) xk2 ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nx * wp / xdirps % L ) ** 2 end do do i = nx / 2 + 2 , nx xkx ( i ) = xkx ( nx - i + 2 ) exs ( i ) = exs ( nx - i + 2 ) xk2 ( i ) = xk2 ( nx - i + 2 ) end do ! periodic-y do i = 1 , ny / 2 + 1 w = 2 * pi * ( i - 1 ) / ny wp = ydirps % stagder_v2p % a * 2 * ydirps % d * sin ( 0.5_dp * w ) & + ydirps % stagder_v2p % b * 2 * ydirps % d * sin ( 1.5_dp * w ) wp = wp / ( 1._dp + 2 * ydirps % stagder_v2p % alpha * cos ( w )) yky ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( ny * wp / ydirps % L ) eys ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( ny * w / ydirps % L ) yk2 ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( ny * wp / ydirps % L ) ** 2 end do do i = ny / 2 + 2 , ny yky ( i ) = yky ( ny - i + 2 ) eys ( i ) = eys ( ny - i + 2 ) yk2 ( i ) = yk2 ( ny - i + 2 ) end do ! periodic-z do i = 1 , nz / 2 + 1 w = 2 * pi * ( i - 1 ) / nz wp = zdirps % stagder_v2p % a * 2 * zdirps % d * sin ( 0.5_dp * w ) & + zdirps % stagder_v2p % b * 2 * zdirps % d * sin ( 1.5_dp * w ) wp = wp / ( 1._dp + 2 * zdirps % stagder_v2p % alpha * cos ( w )) zkz ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nz * wp / zdirps % L ) ezs ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nz * w / zdirps % L ) zk2 ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nz * wp / zdirps % L ) ** 2 end do print * , 'waves array is correctly set only for a single rank run' ! TODO: do loop ranges below are valid only for single rank runs do ka = 1 , nz / 2 + 1 do kb = 1 , ny / sz do j = 1 , nx do i = 1 , sz ix = j ; iy = ( kb - 1 ) * sz + i ; iz = ka rlexs = real ( exs ( ix ), kind = dp ) * xdirps % d rleys = real ( eys ( iy ), kind = dp ) * ydirps % d rlezs = real ( ezs ( iz ), kind = dp ) * zdirps % d xtt = 2 * ( xdirps % interpl_v2p % a * cos ( rlexs * 0.5_dp ) & + xdirps % interpl_v2p % b * cos ( rlexs * 1.5_dp ) & + xdirps % interpl_v2p % c * cos ( rlexs * 2.5_dp ) & + xdirps % interpl_v2p % d * cos ( rlexs * 3.5_dp )) ytt = 2 * ( ydirps % interpl_v2p % a * cos ( rleys * 0.5_dp ) & + ydirps % interpl_v2p % b * cos ( rleys * 1.5_dp ) & + ydirps % interpl_v2p % c * cos ( rleys * 2.5_dp ) & + ydirps % interpl_v2p % d * cos ( rleys * 3.5_dp )) ztt = 2 * ( zdirps % interpl_v2p % a * cos ( rlezs * 0.5_dp ) & + zdirps % interpl_v2p % b * cos ( rlezs * 1.5_dp ) & + zdirps % interpl_v2p % c * cos ( rlezs * 2.5_dp ) & + zdirps % interpl_v2p % d * cos ( rlezs * 3.5_dp )) xt1 = 1._dp + 2 * xdirps % interpl_v2p % alpha * cos ( rlexs ) yt1 = 1._dp + 2 * ydirps % interpl_v2p % alpha * cos ( rleys ) zt1 = 1._dp + 2 * zdirps % interpl_v2p % alpha * cos ( rlezs ) xt2 = xk2 ( ix ) * ((( ytt / yt1 ) * ( ztt / zt1 )) ** 2 ) yt2 = yk2 ( iy ) * ((( xtt / xt1 ) * ( ztt / zt1 )) ** 2 ) zt2 = zk2 ( iz ) * ((( xtt / xt1 ) * ( ytt / yt1 )) ** 2 ) xyzk = xt2 + yt2 + zt2 self % waves ( i , j , ka + ( kb - 1 ) * ( nz / 2 + 1 )) = xyzk end do end do end do end do end subroutine waves_set end module m_poisson_fft","tags":"","loc":"sourcefile/poisson_fft.f90~2.html"},{"title":"tdsops.f90 – x3d2","text":"Source Code module m_cuda_tdsops use iso_fortran_env , only : stderr => error_unit use m_common , only : dp use m_tdsops , only : tdsops_t , tdsops_init implicit none type , extends ( tdsops_t ) :: cuda_tdsops_t !! CUDA extension of the Tridiagonal Solver Operators class. !! !! Regular tdsops_t class is initiated and the coefficient arrays are !! copied into device arrays so that cuda kernels can use them. real ( dp ), device , allocatable :: dist_fw_dev (:), dist_bw_dev (:), & dist_sa_dev (:), dist_sc_dev (:), & dist_af_dev (:) real ( dp ), device , allocatable :: coeffs_dev (:), & coeffs_s_dev (:, :), coeffs_e_dev (:, :) contains end type cuda_tdsops_t interface cuda_tdsops_t module procedure cuda_tdsops_init end interface cuda_tdsops_t contains function cuda_tdsops_init ( n , delta , operation , scheme , n_halo , from_to , & bc_start , bc_end , sym , c_nu , nu0_nu ) & result ( tdsops ) !! Constructor function for the cuda_tdsops_t class. !! See tdsops_t for details. implicit none type ( cuda_tdsops_t ) :: tdsops !! return value of the function integer , intent ( in ) :: n real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: operation , scheme integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to , bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu integer :: n_stencil tdsops % tdsops_t = tdsops_init ( n , delta , operation , scheme , n_halo , & from_to , bc_start , bc_end , sym , & c_nu , nu0_nu ) n_stencil = 2 * tdsops % n_halo + 1 allocate ( tdsops % dist_fw_dev ( n ), tdsops % dist_bw_dev ( n )) allocate ( tdsops % dist_sa_dev ( n ), tdsops % dist_sc_dev ( n )) allocate ( tdsops % dist_af_dev ( n )) allocate ( tdsops % coeffs_dev ( n_stencil )) allocate ( tdsops % coeffs_s_dev ( n_stencil , tdsops % n_halo )) allocate ( tdsops % coeffs_e_dev ( n_stencil , tdsops % n_halo )) tdsops % dist_fw_dev (:) = tdsops % dist_fw (:) tdsops % dist_bw_dev (:) = tdsops % dist_bw (:) tdsops % dist_sa_dev (:) = tdsops % dist_sa (:) tdsops % dist_sc_dev (:) = tdsops % dist_sc (:) tdsops % dist_af_dev (:) = tdsops % dist_af (:) tdsops % coeffs_dev (:) = tdsops % coeffs (:) tdsops % coeffs_s_dev (:, :) = tdsops % coeffs_s (:, :) tdsops % coeffs_e_dev (:, :) = tdsops % coeffs_e (:, :) end function cuda_tdsops_init end module m_cuda_tdsops","tags":"","loc":"sourcefile/tdsops.f90.html"},{"title":"exec_dist.f90 – x3d2","text":"Source Code module m_cuda_exec_dist use cudafor use mpi use m_common , only : dp use m_cuda_common , only : SZ use m_cuda_kernels_dist , only : der_univ_dist , der_univ_subs , & transeq_3fused_dist , transeq_3fused_subs use m_cuda_sendrecv , only : sendrecv_fields , sendrecv_3fields use m_cuda_tdsops , only : cuda_tdsops_t implicit none contains subroutine exec_dist_tds_compact ( & du , u , u_recv_s , u_recv_e , du_send_s , du_send_e , du_recv_s , du_recv_e , & tdsops , nproc , pprev , pnext , blocks , threads & ) implicit none ! du = d(u) real ( dp ), device , dimension (:, :, :), intent ( out ) :: du real ( dp ), device , dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care the data they pass back real ( dp ), device , dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e type ( cuda_tdsops_t ), intent ( in ) :: tdsops integer , intent ( in ) :: nproc , pprev , pnext type ( dim3 ), intent ( in ) :: blocks , threads integer :: n_data n_data = SZ * 1 * blocks % x call der_univ_dist <<< blocks , threads >>> ( & du , du_send_s , du_send_e , u , u_recv_s , u_recv_e , & tdsops % coeffs_s_dev , tdsops % coeffs_e_dev , tdsops % coeffs_dev , & tdsops % n , tdsops % dist_fw_dev , tdsops % dist_bw_dev , tdsops % dist_af_dev & ) ! halo exchange for 2x2 systems call sendrecv_fields ( du_recv_s , du_recv_e , du_send_s , du_send_e , & n_data , nproc , pprev , pnext ) call der_univ_subs <<< blocks , threads >>> ( & du , du_recv_s , du_recv_e , & tdsops % n , tdsops % dist_sa_dev , tdsops % dist_sc_dev & ) end subroutine exec_dist_tds_compact subroutine exec_dist_transeq_3fused ( & r_u , u , u_recv_s , u_recv_e , v , v_recv_s , v_recv_e , & du , dud , d2u , & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e , & der1st , der2nd , nu , nproc , pprev , pnext , blocks , threads & ) implicit none ! r_u = -1/2*(v*d1(u) + d1(u*v)) + nu*d2(u) real ( dp ), device , dimension (:, :, :), intent ( out ) :: r_u real ( dp ), device , dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e real ( dp ), device , dimension (:, :, :), intent ( in ) :: v , v_recv_s , v_recv_e ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care the data they pass back real ( dp ), device , dimension (:, :, :), intent ( out ) :: du , dud , d2u real ( dp ), device , dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e type ( cuda_tdsops_t ), intent ( in ) :: der1st , der2nd real ( dp ), intent ( in ) :: nu integer , intent ( in ) :: nproc , pprev , pnext type ( dim3 ), intent ( in ) :: blocks , threads integer :: n_data n_data = SZ * 1 * blocks % x call transeq_3fused_dist <<< blocks , threads >>> ( & du , dud , d2u , & du_send_s , du_send_e , & dud_send_s , dud_send_e , & d2u_send_s , d2u_send_e , & u , u_recv_s , u_recv_e , & v , v_recv_s , v_recv_e , der1st % n , & der1st % coeffs_s_dev , der1st % coeffs_e_dev , der1st % coeffs_dev , & der1st % dist_fw_dev , der1st % dist_bw_dev , der1st % dist_af_dev , & der2nd % coeffs_s_dev , der2nd % coeffs_e_dev , der2nd % coeffs_dev , & der2nd % dist_fw_dev , der2nd % dist_bw_dev , der2nd % dist_af_dev & ) ! halo exchange for 2x2 systems call sendrecv_3fields ( & du_recv_s , du_recv_e , dud_recv_s , dud_recv_e , & d2u_recv_s , d2u_recv_e , & du_send_s , du_send_e , dud_send_s , dud_send_e , & d2u_send_s , d2u_send_e , & n_data , nproc , pprev , pnext & ) call transeq_3fused_subs <<< blocks , threads >>> ( & r_u , v , du , dud , d2u , & du_recv_s , du_recv_e , & dud_recv_s , dud_recv_e , & d2u_recv_s , d2u_recv_e , & der1st % dist_sa_dev , der1st % dist_sc_dev , & der2nd % dist_sa_dev , der2nd % dist_sc_dev , & der1st % n , nu & ) end subroutine exec_dist_transeq_3fused end module m_cuda_exec_dist","tags":"","loc":"sourcefile/exec_dist.f90.html"},{"title":"reorder.f90 – x3d2","text":"Source Code module m_cuda_kernels_reorder use cudafor use m_common , only : dp use m_cuda_common , only : SZ contains attributes ( global ) subroutine reorder_x2y ( u_y , u_x , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_y real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_x integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_x ( i , j + ( b_i - 1 ) * SZ , b_j + ( b_k - 1 ) * nz ) call syncthreads () ! copy into output array from shared u_y ( i , j + ( b_k - 1 ) * SZ , b_j + ( b_i - 1 ) * nz ) = tile ( j , i ) end subroutine reorder_x2y attributes ( global ) subroutine reorder_x2z ( u_z , u_x , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_z real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_x integer , value , intent ( in ) :: nz integer :: i , j , b_i , b_j , nx i = threadIdx % x ; b_i = blockIdx % x ; b_j = blockIdx % y nx = gridDim % x ! Data access pattern for reordering between x and z is quite nice ! thus we don't need to use shared memory for this operation. do j = 1 , nz u_z ( i , j , b_i + ( b_j - 1 ) * nx ) = u_x ( i , b_i , j + ( b_j - 1 ) * nz ) end do end subroutine reorder_x2z attributes ( global ) subroutine reorder_y2x ( u_x , u_y , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_y integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_y ( i , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) call syncthreads () ! copy into output array from shared u_x ( i , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + b_k ) = tile ( j , i ) end subroutine reorder_y2x attributes ( global ) subroutine reorder_y2z ( u_z , u_y , nx , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_z real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_y integer , value , intent ( in ) :: nx , nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_y ( i , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) call syncthreads () ! copy into output array from shared u_z ( i , b_k , ( b_i - 1 ) * SZ + j + ( b_j - 1 ) * nx ) = tile ( j , i ) end subroutine reorder_y2z attributes ( global ) subroutine reorder_z2x ( u_x , u_z , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_z integer , value , intent ( in ) :: nz integer :: i , j , b_i , b_j , nx i = threadIdx % x ; b_i = blockIdx % x ; b_j = blockIdx % y nx = gridDim % x do j = 1 , nz u_x ( i , b_i , j + ( b_j - 1 ) * nz ) = u_z ( i , j , b_i + ( b_j - 1 ) * nx ) end do end subroutine reorder_z2x attributes ( global ) subroutine reorder_z2y ( u_y , u_z , nx , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_y real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_z integer , value , intent ( in ) :: nx , nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_z ( i , b_k , ( b_i - 1 ) * SZ + j + ( b_j - 1 ) * nx ) call syncthreads () ! copy into output array from shared u_y ( i , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) = tile ( j , i ) end subroutine reorder_z2y attributes ( global ) subroutine sum_yintox ( u_x , u_y , nz ) implicit none real ( dp ), device , intent ( inout ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_y integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_y ( i , ( b_j - 1 ) * SZ + j , ( b_k ) + nz * ( b_i - 1 )) call syncthreads () ! copy into output array from shared u_x ( i , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + ( b_k )) = & u_x ( i , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + ( b_k )) + tile ( j , i ) end subroutine sum_yintox attributes ( global ) subroutine sum_zintox ( u_x , u_z , nz ) implicit none ! Arguments real ( dp ), device , intent ( inout ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_z integer , value , intent ( in ) :: nz integer :: i , j , b_i , b_j , nx i = threadIdx % x ; b_i = blockIdx % x ; b_j = blockIdx % y nx = gridDim % x do j = 1 , nz u_x ( i , b_i , j + ( b_j - 1 ) * nz ) = u_x ( i , b_i , j + ( b_j - 1 ) * nz ) & + u_z ( i , j , b_i + ( b_j - 1 ) * nx ) end do end subroutine sum_zintox attributes ( global ) subroutine axpby ( n , alpha , x , beta , y ) implicit none integer , value , intent ( in ) :: n real ( dp ), value , intent ( in ) :: alpha , beta real ( dp ), device , intent ( in ), dimension (:, :, :) :: x real ( dp ), device , intent ( inout ), dimension (:, :, :) :: y integer :: i , j , b i = threadIdx % x b = blockIdx % x do j = 1 , n y ( i , j , b ) = alpha * x ( i , j , b ) + beta * y ( i , j , b ) end do end subroutine axpby attributes ( global ) subroutine scalar_product ( s , x , y , n ) implicit none real ( dp ), device , intent ( inout ) :: s real ( dp ), device , intent ( in ), dimension (:, :, :) :: x , y integer , value , intent ( in ) :: n real ( dp ) :: s_pncl !! pencil sum integer :: i , j , b , ierr i = threadIdx % x b = blockIdx % x s_pncl = 0._dp do j = 1 , n s_pncl = s_pncl + x ( i , j , b ) * y ( i , j , b ) end do ierr = atomicadd ( s , s_pncl ) end subroutine scalar_product attributes ( global ) subroutine buffer_copy ( u_send_s , u_send_e , u , n , n_halo ) implicit none real ( dp ), device , intent ( inout ), dimension (:, :, :) :: u_send_s , u_send_e real ( dp ), device , intent ( in ), dimension (:, :, :) :: u integer , value , intent ( in ) :: n , n_halo integer :: i , j , b i = threadIdx % x b = blockIdx % x do j = 1 , n_halo u_send_s ( i , j , b ) = u ( i , j , b ) u_send_e ( i , j , b ) = u ( i , n - n_halo + j , b ) end do end subroutine buffer_copy end module m_cuda_kernels_reorder","tags":"","loc":"sourcefile/reorder.f90.html"},{"title":"common.f90 – x3d2","text":"Source Code module m_cuda_common implicit none integer , parameter :: SZ = 32 end module m_cuda_common","tags":"","loc":"sourcefile/common.f90.html"},{"title":"common.f90 – x3d2","text":"Source Code module m_omp_common implicit none integer , parameter :: SZ = 16 end module m_omp_common","tags":"","loc":"sourcefile/common.f90~2.html"},{"title":"kernels_dist.f90 – x3d2","text":"Source Code module m_omp_kernels_dist use omp_lib use m_common , only : dp use m_omp_common , only : SZ implicit none contains subroutine der_univ_dist ( & du , send_u_s , send_u_e , u , u_s , u_e , coeffs_s , coeffs_e , coeffs , n , & ffr , fbc , faf & ) implicit none ! Arguments real ( dp ), intent ( out ), dimension (:, :) :: du , send_u_s , send_u_e real ( dp ), intent ( in ), dimension (:, :) :: u , u_s , u_e real ( dp ), intent ( in ), dimension (:, :) :: coeffs_s , coeffs_e ! start/end real ( dp ), intent ( in ), dimension (:) :: coeffs integer , intent ( in ) :: n real ( dp ), intent ( in ), dimension (:) :: ffr , fbc , faf ! Local variables integer :: i , j !, b real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 , & temp_du , alpha , last_r ! store bulk coeffs in the registers c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) last_r = ffr ( 1 ) !$omp simd do i = 1 , SZ du ( i , 1 ) = coeffs_s ( 1 , 1 ) * u_s ( i , 1 ) & + coeffs_s ( 2 , 1 ) * u_s ( i , 2 ) & + coeffs_s ( 3 , 1 ) * u_s ( i , 3 ) & + coeffs_s ( 4 , 1 ) * u_s ( i , 4 ) & + coeffs_s ( 5 , 1 ) * u ( i , 1 ) & + coeffs_s ( 6 , 1 ) * u ( i , 2 ) & + coeffs_s ( 7 , 1 ) * u ( i , 3 ) & + coeffs_s ( 8 , 1 ) * u ( i , 4 ) & + coeffs_s ( 9 , 1 ) * u ( i , 5 ) du ( i , 1 ) = du ( i , 1 ) * faf ( 1 ) du ( i , 2 ) = coeffs_s ( 1 , 2 ) * u_s ( i , 2 ) & + coeffs_s ( 2 , 2 ) * u_s ( i , 3 ) & + coeffs_s ( 3 , 2 ) * u_s ( i , 4 ) & + coeffs_s ( 4 , 2 ) * u ( i , 1 ) & + coeffs_s ( 5 , 2 ) * u ( i , 2 ) & + coeffs_s ( 6 , 2 ) * u ( i , 3 ) & + coeffs_s ( 7 , 2 ) * u ( i , 4 ) & + coeffs_s ( 8 , 2 ) * u ( i , 5 ) & + coeffs_s ( 9 , 2 ) * u ( i , 6 ) du ( i , 2 ) = du ( i , 2 ) * faf ( 2 ) du ( i , 3 ) = coeffs_s ( 1 , 3 ) * u_s ( i , 3 ) & + coeffs_s ( 2 , 3 ) * u_s ( i , 4 ) & + coeffs_s ( 3 , 3 ) * u ( i , 1 ) & + coeffs_s ( 4 , 3 ) * u ( i , 2 ) & + coeffs_s ( 5 , 3 ) * u ( i , 3 ) & + coeffs_s ( 6 , 3 ) * u ( i , 4 ) & + coeffs_s ( 7 , 3 ) * u ( i , 5 ) & + coeffs_s ( 8 , 3 ) * u ( i , 6 ) & + coeffs_s ( 9 , 3 ) * u ( i , 7 ) du ( i , 3 ) = ffr ( 3 ) * ( du ( i , 3 ) - faf ( 3 ) * du ( i , 2 )) du ( i , 4 ) = coeffs_s ( 1 , 4 ) * u_s ( i , 4 ) & + coeffs_s ( 2 , 4 ) * u ( i , 1 ) & + coeffs_s ( 3 , 4 ) * u ( i , 2 ) & + coeffs_s ( 4 , 4 ) * u ( i , 3 ) & + coeffs_s ( 5 , 4 ) * u ( i , 4 ) & + coeffs_s ( 6 , 4 ) * u ( i , 5 ) & + coeffs_s ( 7 , 4 ) * u ( i , 6 ) & + coeffs_s ( 8 , 4 ) * u ( i , 7 ) & + coeffs_s ( 9 , 4 ) * u ( i , 8 ) du ( i , 4 ) = ffr ( 4 ) * ( du ( i , 4 ) - faf ( 4 ) * du ( i , 3 )) end do !$omp end simd ! alpha is always the same in the bulk region for us alpha = faf ( 5 ) do j = 5 , n - 4 !$omp simd do i = 1 , SZ temp_du = c_m4 * u ( i , j - 4 ) + c_m3 * u ( i , j - 3 ) & + c_m2 * u ( i , j - 2 ) + c_m1 * u ( i , j - 1 ) & + c_j * u ( i , j ) & + c_p1 * u ( i , j + 1 ) + c_p2 * u ( i , j + 2 ) & + c_p3 * u ( i , j + 3 ) + c_p4 * u ( i , j + 4 ) du ( i , j ) = ffr ( j ) * ( temp_du - alpha * du ( i , j - 1 )) end do !$omp end simd end do !$omp simd do i = 1 , SZ j = n - 3 du ( i , j ) = coeffs_e ( 1 , 1 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 1 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 1 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 1 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 1 ) * u ( i , j ) & + coeffs_e ( 6 , 1 ) * u ( i , j + 1 ) & + coeffs_e ( 7 , 1 ) * u ( i , j + 2 ) & + coeffs_e ( 8 , 1 ) * u ( i , j + 3 ) & + coeffs_e ( 9 , 1 ) * u_e ( i , 1 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) j = n - 2 du ( i , j ) = coeffs_e ( 1 , 2 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 2 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 2 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 2 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 2 ) * u ( i , j ) & + coeffs_e ( 6 , 2 ) * u ( i , j + 1 ) & + coeffs_e ( 7 , 2 ) * u ( i , j + 2 ) & + coeffs_e ( 8 , 2 ) * u_e ( i , 1 ) & + coeffs_e ( 9 , 2 ) * u_e ( i , 2 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) j = n - 1 du ( i , j ) = coeffs_e ( 1 , 3 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 3 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 3 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 3 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 3 ) * u ( i , j ) & + coeffs_e ( 6 , 3 ) * u ( i , j + 1 ) & + coeffs_e ( 7 , 3 ) * u_e ( i , 1 ) & + coeffs_e ( 8 , 3 ) * u_e ( i , 2 ) & + coeffs_e ( 9 , 3 ) * u_e ( i , 3 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) j = n du ( i , j ) = coeffs_e ( 1 , 4 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 4 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 4 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 4 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 4 ) * u ( i , j ) & + coeffs_e ( 6 , 4 ) * u_e ( i , 1 ) & + coeffs_e ( 7 , 4 ) * u_e ( i , 2 ) & + coeffs_e ( 8 , 4 ) * u_e ( i , 3 ) & + coeffs_e ( 9 , 4 ) * u_e ( i , 4 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) end do !$omp end simd !$omp simd do i = 1 , SZ send_u_e ( i , 1 ) = du ( i , n ) end do !$omp end simd ! Backward pass of the hybrid algorithm do j = n - 2 , 2 , - 1 !$omp simd do i = 1 , SZ du ( i , j ) = du ( i , j ) - fbc ( j ) * du ( i , j + 1 ) end do !$omp end simd end do !$omp simd do i = 1 , SZ du ( i , 1 ) = last_r * ( du ( i , 1 ) - fbc ( 1 ) * du ( i , 2 )) send_u_s ( i , 1 ) = du ( i , 1 ) end do !$omp end simd end subroutine der_univ_dist subroutine der_univ_subs ( du , recv_u_s , recv_u_e , n , dist_sa , dist_sc ) implicit none ! Arguments real ( dp ), intent ( out ), dimension (:, :) :: du real ( dp ), intent ( in ), dimension (:, :) :: recv_u_s , recv_u_e real ( dp ), intent ( in ), dimension (:) :: dist_sa , dist_sc integer , intent ( in ) :: n ! Local variables integer :: i , j !, b real ( dp ) :: ur , bl , recp real ( dp ), dimension ( SZ ) :: du_s , du_e !$omp simd do i = 1 , SZ ! A small trick we do here is valid for symmetric Toeplitz matrices. ! In our case our matrices satisfy this criteria in the (5:n-4) region ! and as long as a rank has around at least 20 entries the assumptions ! we make here are perfectly valid. ! bl is the bottom left entry in the 2x2 matrix ! ur is the upper right entry in the 2x2 matrix ! Start ! At the start we have the 'bl', and assume 'ur' bl = dist_sa ( 1 ) ur = dist_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) du_s ( i ) = recp * ( du ( i , 1 ) - bl * recv_u_s ( i , 1 )) ! End ! At the end we have the 'ur', and assume 'bl' bl = dist_sc ( n ) ur = dist_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) du_e ( i ) = recp * ( du ( i , n ) - ur * recv_u_e ( i , 1 )) end do !$omp end simd !$omp simd do i = 1 , SZ du ( i , 1 ) = du_s ( i ) end do !$omp end simd do j = 2 , n - 1 !$omp simd do i = 1 , SZ du ( i , j ) = ( du ( i , j ) - dist_sa ( j ) * du_s ( i ) - dist_sc ( j ) * du_e ( i )) end do !$omp end simd end do !$omp simd do i = 1 , SZ du ( i , n ) = du_e ( i ) end do !$omp end simd end subroutine der_univ_subs end module m_omp_kernels_dist","tags":"","loc":"sourcefile/kernels_dist.f90.html"},{"title":"distributed.f90 – x3d2","text":"Source Code module m_cuda_kernels_dist use cudafor use m_common , only : dp implicit none contains attributes ( global ) subroutine der_univ_dist ( & du , send_u_s , send_u_e , u , u_s , u_e , coeffs_s , coeffs_e , coeffs , n , & ffr , fbc , faf & ) implicit none ! Arguments real ( dp ), device , intent ( out ), dimension (:, :, :) :: du , send_u_s , & send_u_e real ( dp ), device , intent ( in ), dimension (:, :, :) :: u , u_s , u_e real ( dp ), device , intent ( in ), dimension (:, :) :: coeffs_s , coeffs_e real ( dp ), device , intent ( in ), dimension (:) :: coeffs integer , value , intent ( in ) :: n real ( dp ), device , intent ( in ), dimension (:) :: ffr , fbc , faf ! Local variables integer :: i , j , b , k , lj integer :: jm2 , jm1 , jp1 , jp2 real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 , & temp_du , alpha , last_r i = threadIdx % x b = blockIdx % x ! store bulk coeffs in the registers c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) last_r = ffr ( 1 ) du ( i , 1 , b ) = coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) & + coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) & + coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) & + coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) & + coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) & + coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) & + coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) & + coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) & + coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) du ( i , 1 , b ) = du ( i , 1 , b ) * faf ( 1 ) du ( i , 2 , b ) = coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) & + coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) & + coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) & + coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) & + coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) & + coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) & + coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) & + coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) & + coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) du ( i , 2 , b ) = du ( i , 2 , b ) * faf ( 2 ) du ( i , 3 , b ) = coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) & + coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) & + coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) & + coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) & + coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) & + coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) & + coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) & + coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) & + coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) du ( i , 3 , b ) = ffr ( 3 ) * ( du ( i , 3 , b ) - faf ( 3 ) * du ( i , 2 , b )) du ( i , 4 , b ) = coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) & + coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) & + coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) & + coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) & + coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) & + coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) & + coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) & + coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) & + coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) du ( i , 4 , b ) = ffr ( 4 ) * ( du ( i , 4 , b ) - faf ( 3 ) * du ( i , 3 , b )) alpha = faf ( 5 ) do j = 5 , n - 4 temp_du = c_m4 * u ( i , j - 4 , b ) + c_m3 * u ( i , j - 3 , b ) & + c_m2 * u ( i , j - 2 , b ) + c_m1 * u ( i , j - 1 , b ) & + c_j * u ( i , j , b ) & + c_p1 * u ( i , j + 1 , b ) + c_p2 * u ( i , j + 2 , b ) & + c_p3 * u ( i , j + 3 , b ) + c_p4 * u ( i , j + 4 , b ) du ( i , j , b ) = ffr ( j ) * ( temp_du - alpha * du ( i , j - 1 , b )) end do j = n - 3 du ( i , j , b ) = coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 1 ) * u ( i , j , b ) & + coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) & + coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) & + coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) j = n - 2 du ( i , j , b ) = coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 2 ) * u ( i , j , b ) & + coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) & + coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) & + coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) j = n - 1 du ( i , j , b ) = coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 3 ) * u ( i , j , b ) & + coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) & + coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) & + coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) j = n du ( i , j , b ) = coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 4 ) * u ( i , j , b ) & + coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) & + coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) & + coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) & + coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) send_u_e ( i , 1 , b ) = du ( i , n , b ) ! Backward pass of the hybrid algorithm do j = n - 2 , 2 , - 1 du ( i , j , b ) = du ( i , j , b ) - fbc ( j ) * du ( i , j + 1 , b ) end do du ( i , 1 , b ) = last_r * ( du ( i , 1 , b ) - fbc ( 1 ) * du ( i , 2 , b )) send_u_s ( i , 1 , b ) = du ( i , 1 , b ) end subroutine der_univ_dist attributes ( global ) subroutine der_univ_subs ( du , recv_u_s , recv_u_e , & n , dist_sa , dist_sc ) implicit none ! Arguments real ( dp ), device , intent ( out ), dimension (:, :, :) :: du real ( dp ), device , intent ( in ), dimension (:, :, :) :: recv_u_s , recv_u_e real ( dp ), device , intent ( in ), dimension (:) :: dist_sa , dist_sc integer , value , intent ( in ) :: n ! Local variables integer :: i , j , b real ( dp ) :: ur , bl , recp , du_s , du_e i = threadIdx % x b = blockIdx % x ! A small trick we do here is valid for symmetric Toeplitz matrices. ! In our case our matrices satisfy this criteria in the (5:n-4) region ! and as long as a rank has around at least 20 entries the assumptions ! we make here are perfectly valid. ! bl is the bottom left entry in the 2x2 matrix ! ur is the upper right entry in the 2x2 matrix ! Start ! At the start we have the 'bl', and assume 'ur' bl = dist_sa ( 1 ) ur = dist_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) du_s = recp * ( du ( i , 1 , b ) - bl * recv_u_s ( i , 1 , b )) ! End ! At the end we have the 'ur', and assume 'bl' bl = dist_sc ( n ) ur = dist_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) du_e = recp * ( du ( i , n , b ) - ur * recv_u_e ( i , 1 , b )) du ( i , 1 , b ) = du_s do j = 2 , n - 1 du ( i , j , b ) = ( du ( i , j , b ) - dist_sa ( j ) * du_s - dist_sc ( j ) * du_e ) end do du ( i , n , b ) = du_e end subroutine der_univ_subs attributes ( global ) subroutine transeq_3fused_dist ( & du , dud , d2u , & send_du_s , send_du_e , send_dud_s , send_dud_e , send_d2u_s , send_d2u_e , & u , u_s , u_e , v , v_s , v_e , n , & d1_coeffs_s , d1_coeffs_e , d1_coeffs , d1_fw , d1_bw , d1_af , & d2_coeffs_s , d2_coeffs_e , d2_coeffs , d2_fw , d2_bw , d2_af & ) implicit none ! Arguments real ( dp ), device , intent ( out ), dimension (:, :, :) :: du , dud , d2u real ( dp ), device , intent ( out ), dimension (:, :, :) :: & send_du_s , send_du_e , send_dud_s , send_dud_e , send_d2u_s , send_d2u_e real ( dp ), device , intent ( in ), dimension (:, :, :) :: u , u_s , u_e , & v , v_s , v_e integer , value , intent ( in ) :: n real ( dp ), device , intent ( in ) :: d1_coeffs_s (:, :), d1_coeffs_e (:, :), & d1_coeffs (:) real ( dp ), device , intent ( in ) :: d1_fw (:), d1_bw (:), d1_af (:) real ( dp ), device , intent ( in ) :: d2_coeffs_s (:, :), d2_coeffs_e (:, :), & d2_coeffs (:) real ( dp ), device , intent ( in ) :: d2_fw (:), d2_bw (:), d2_af (:) ! Local variables integer :: i , j , b real ( dp ) :: d1_c_m4 , d1_c_m3 , d1_c_m2 , d1_c_m1 , d1_c_j , & d1_c_p1 , d1_c_p2 , d1_c_p3 , d1_c_p4 , & d1_alpha , d1_last_r real ( dp ) :: d2_c_m4 , d2_c_m3 , d2_c_m2 , d2_c_m1 , d2_c_j , & d2_c_p1 , d2_c_p2 , d2_c_p3 , d2_c_p4 , & d2_alpha , d2_last_r real ( dp ) :: temp_du , temp_dud , temp_d2u real ( dp ) :: u_m4 , u_m3 , u_m2 , u_m1 , u_j , u_p1 , u_p2 , u_p3 , u_p4 real ( dp ) :: v_m4 , v_m3 , v_m2 , v_m1 , v_j , v_p1 , v_p2 , v_p3 , v_p4 real ( dp ) :: old_du , old_dud , old_d2u i = threadIdx % x b = blockIdx % x d1_last_r = d1_fw ( 1 ) d2_last_r = d2_fw ( 1 ) ! j = 1 temp_du = d1_coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) & + d1_coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) & + d1_coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) & + d1_coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) & + d1_coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) & + d1_coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) & + d1_coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) & + d1_coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) & + d1_coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) du ( i , 1 , b ) = temp_du * d1_af ( 1 ) temp_dud = d1_coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) * v_s ( i , 1 , b ) & + d1_coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) * v_s ( i , 2 , b ) & + d1_coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) * v_s ( i , 3 , b ) & + d1_coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + d1_coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + d1_coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + d1_coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + d1_coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + d1_coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) * v ( i , 5 , b ) dud ( i , 1 , b ) = temp_dud * d1_af ( 1 ) temp_d2u = d2_coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) & + d2_coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) & + d2_coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) & + d2_coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) & + d2_coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) & + d2_coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) & + d2_coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) & + d2_coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) & + d2_coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) d2u ( i , 1 , b ) = temp_d2u * d2_af ( 1 ) ! j = 2 temp_du = d1_coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) & + d1_coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) & + d1_coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) & + d1_coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) & + d1_coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) & + d1_coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) & + d1_coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) & + d1_coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) & + d1_coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) du ( i , 2 , b ) = temp_du * d1_af ( 2 ) temp_dud = d1_coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) * v_s ( i , 2 , b ) & + d1_coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) * v_s ( i , 3 , b ) & + d1_coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + d1_coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + d1_coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + d1_coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + d1_coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + d1_coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) * v ( i , 5 , b ) & + d1_coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) * v ( i , 6 , b ) dud ( i , 2 , b ) = temp_dud * d1_af ( 2 ) temp_d2u = d2_coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) & + d2_coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) & + d2_coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) & + d2_coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) & + d2_coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) & + d2_coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) & + d2_coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) & + d2_coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) & + d2_coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) d2u ( i , 2 , b ) = temp_d2u * d2_af ( 2 ) ! j = 3 temp_du = d1_coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) & + d1_coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) & + d1_coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) & + d1_coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) & + d1_coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) & + d1_coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) & + d1_coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) & + d1_coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) & + d1_coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) du ( i , 3 , b ) = d1_fw ( 3 ) * ( temp_du - d1_af ( 3 ) * du ( i , 2 , b )) temp_dud = d1_coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) * v_s ( i , 3 , b ) & + d1_coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + d1_coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + d1_coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + d1_coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + d1_coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + d1_coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) * v ( i , 5 , b ) & + d1_coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) * v ( i , 6 , b ) & + d1_coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) * v ( i , 7 , b ) dud ( i , 3 , b ) = d1_fw ( 3 ) * ( temp_dud - d1_af ( 3 ) * dud ( i , 2 , b )) temp_d2u = d2_coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) & + d2_coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) & + d2_coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) & + d2_coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) & + d2_coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) & + d2_coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) & + d2_coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) & + d2_coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) & + d2_coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) d2u ( i , 3 , b ) = d2_fw ( 3 ) * ( temp_d2u - d2_af ( 3 ) * d2u ( i , 2 , b )) ! j = 4 temp_du = d1_coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) & + d1_coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) & + d1_coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) & + d1_coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) & + d1_coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) & + d1_coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) & + d1_coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) & + d1_coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) & + d1_coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) du ( i , 4 , b ) = d1_fw ( 4 ) * ( temp_du - d1_af ( 3 ) * du ( i , 3 , b )) temp_dud = d1_coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + d1_coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + d1_coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + d1_coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + d1_coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + d1_coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) * v ( i , 5 , b ) & + d1_coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) * v ( i , 6 , b ) & + d1_coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) * v ( i , 7 , b ) & + d1_coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) * v ( i , 8 , b ) dud ( i , 4 , b ) = d1_fw ( 4 ) * ( temp_dud - d1_af ( 3 ) * dud ( i , 3 , b )) temp_d2u = d2_coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) & + d2_coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) & + d2_coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) & + d2_coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) & + d2_coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) & + d2_coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) & + d2_coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) & + d2_coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) & + d2_coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) d2u ( i , 4 , b ) = d2_fw ( 4 ) * ( temp_d2u - d2_af ( 3 ) * d2u ( i , 3 , b )) d1_alpha = d1_af ( 5 ) d2_alpha = d2_af ( 5 ) ! store bulk coeffs in the registers d1_c_m4 = d1_coeffs ( 1 ); d1_c_m3 = d1_coeffs ( 2 ) d1_c_m2 = d1_coeffs ( 3 ); d1_c_m1 = d1_coeffs ( 4 ) d1_c_j = d1_coeffs ( 5 ) d1_c_p1 = d1_coeffs ( 6 ); d1_c_p2 = d1_coeffs ( 7 ) d1_c_p3 = d1_coeffs ( 8 ); d1_c_p4 = d1_coeffs ( 9 ) d2_c_m4 = d2_coeffs ( 1 ); d2_c_m3 = d2_coeffs ( 2 ) d2_c_m2 = d2_coeffs ( 3 ); d2_c_m1 = d2_coeffs ( 4 ) d2_c_j = d2_coeffs ( 5 ) d2_c_p1 = d2_coeffs ( 6 ); d2_c_p2 = d2_coeffs ( 7 ) d2_c_p3 = d2_coeffs ( 8 ); d2_c_p4 = d2_coeffs ( 9 ) ! It is better to access d?(i, j - 1, b) via old_d? old_du = du ( i , 4 , b ) old_dud = dud ( i , 4 , b ) old_d2u = d2u ( i , 4 , b ) ! Populate registers with the u and v stencils u_m4 = u ( i , 1 , b ); u_m3 = u ( i , 2 , b ) u_m2 = u ( i , 3 , b ); u_m1 = u ( i , 4 , b ) u_j = u ( i , 5 , b ); u_p1 = u ( i , 6 , b ) u_p2 = u ( i , 7 , b ); u_p3 = u ( i , 8 , b ) v_m4 = v ( i , 1 , b ); v_m3 = v ( i , 2 , b ) v_m2 = v ( i , 3 , b ); v_m1 = v ( i , 4 , b ) v_j = v ( i , 5 , b ); v_p1 = v ( i , 6 , b ) v_p2 = v ( i , 7 , b ); v_p3 = v ( i , 8 , b ) do j = 5 , n - 4 u_p4 = u ( i , j + 4 , b ); v_p4 = v ( i , j + 4 , b ) ! du temp_du = d1_c_m4 * u_m4 + d1_c_m3 * u_m3 + d1_c_m2 * u_m2 + d1_c_m1 * u_m1 & + d1_c_j * u_j & + d1_c_p1 * u_p1 + d1_c_p2 * u_p2 + d1_c_p3 * u_p3 + d1_c_p4 * u_p4 du ( i , j , b ) = d1_fw ( j ) * ( temp_du - d1_alpha * old_du ) old_du = du ( i , j , b ) ! dud temp_dud = d1_c_m4 * u_m4 * v_m4 + d1_c_m3 * u_m3 * v_m3 & + d1_c_m2 * u_m2 * v_m2 + d1_c_m1 * u_m1 * v_m1 & + d1_c_j * u_j * v_j & + d1_c_p1 * u_p1 * v_p1 + d1_c_p2 * u_p2 * v_p2 & + d1_c_p3 * u_p3 * v_p3 + d1_c_p4 * u_p4 * v_p4 dud ( i , j , b ) = d1_fw ( j ) * ( temp_dud - d1_alpha * old_dud ) old_dud = dud ( i , j , b ) ! d2u temp_d2u = d2_c_m4 * u_m4 + d2_c_m3 * u_m3 + d2_c_m2 * u_m2 + d2_c_m1 * u_m1 & + d2_c_j * u_j & + d2_c_p1 * u_p1 + d2_c_p2 * u_p2 + d2_c_p3 * u_p3 + d2_c_p4 * u_p4 d2u ( i , j , b ) = d2_fw ( j ) * ( temp_d2u - d2_alpha * old_d2u ) old_d2u = d2u ( i , j , b ) ! Prepare registers for the next step u_m4 = u_m3 ; u_m3 = u_m2 ; u_m2 = u_m1 ; u_m1 = u_j u_j = u_p1 ; u_p1 = u_p2 ; u_p2 = u_p3 ; u_p3 = u_p4 v_m4 = v_m3 ; v_m3 = v_m2 ; v_m2 = v_m1 ; v_m1 = v_j v_j = v_p1 ; v_p1 = v_p2 ; v_p2 = v_p3 ; v_p3 = v_p4 end do j = n - 3 temp_du = d1_coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 1 ) * u ( i , j , b ) & + d1_coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) & + d1_coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) & + d1_coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) du ( i , j , b ) = d1_fw ( j ) * ( temp_du - d1_af ( j ) * du ( i , j - 1 , b )) temp_dud = d1_coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 1 ) * u ( i , j , b ) * v ( i , j , b ) & + d1_coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) * v ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) * v ( i , j + 2 , b ) & + d1_coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) * v ( i , j + 3 , b ) & + d1_coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) dud ( i , j , b ) = d1_fw ( j ) * ( temp_dud - d1_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d1_coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) & + d2_coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) & + d2_coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) & + d2_coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) & + d2_coeffs_e ( 5 , 1 ) * u ( i , j , b ) & + d2_coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) & + d2_coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) & + d2_coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) & + d2_coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) d2u ( i , j , b ) = d2_fw ( j ) * ( temp_d2u - d2_af ( j ) * d2u ( i , j - 1 , b )) j = n - 2 temp_du = d1_coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 2 ) * u ( i , j , b ) & + d1_coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) & + d1_coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) & + d1_coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) du ( i , j , b ) = d1_fw ( j ) * ( temp_du - d1_af ( j ) * du ( i , j - 1 , b )) temp_dud = d1_coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 2 ) * u ( i , j , b ) * v ( i , j , b ) & + d1_coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) * v ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) * v ( i , j + 2 , b ) & + d1_coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) & + d1_coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) * v_e ( i , 2 , b ) dud ( i , j , b ) = d1_fw ( j ) * ( temp_dud - d1_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d2_coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) & + d2_coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) & + d2_coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) & + d2_coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) & + d2_coeffs_e ( 5 , 2 ) * u ( i , j , b ) & + d2_coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) & + d2_coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) & + d2_coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) & + d2_coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) d2u ( i , j , b ) = d2_fw ( j ) * ( temp_d2u - d2_af ( j ) * d2u ( i , j - 1 , b )) j = n - 1 temp_du = d1_coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 3 ) * u ( i , j , b ) & + d1_coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) & + d1_coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) & + d1_coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) du ( i , j , b ) = d1_fw ( j ) * ( temp_du - d1_af ( j ) * du ( i , j - 1 , b )) temp_dud = d1_coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 3 ) * u ( i , j , b ) * v ( i , j , b ) & + d1_coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) * v ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) & + d1_coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) * v_e ( i , 2 , b ) & + d1_coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) * v_e ( i , 3 , b ) dud ( i , j , b ) = d1_fw ( j ) * ( temp_dud - d1_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d2_coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) & + d2_coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) & + d2_coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) & + d2_coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) & + d2_coeffs_e ( 5 , 3 ) * u ( i , j , b ) & + d2_coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) & + d2_coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) & + d2_coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) & + d2_coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) d2u ( i , j , b ) = d2_fw ( j ) * ( temp_d2u - d2_af ( j ) * d2u ( i , j - 1 , b )) j = n temp_du = d1_coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 4 ) * u ( i , j , b ) & + d1_coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) & + d1_coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) & + d1_coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) & + d1_coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) du ( i , j , b ) = d1_fw ( j ) * ( temp_du - d1_af ( j ) * du ( i , j - 1 , b )) temp_dud = d1_coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 4 ) * u ( i , j , b ) * v ( i , j , b ) & + d1_coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) & + d1_coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) * v_e ( i , 2 , b ) & + d1_coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) * v_e ( i , 3 , b ) & + d1_coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) * v_e ( i , 4 , b ) dud ( i , j , b ) = d1_fw ( j ) * ( temp_dud - d1_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d2_coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) & + d2_coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) & + d2_coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) & + d2_coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) & + d2_coeffs_e ( 5 , 4 ) * u ( i , j , b ) & + d2_coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) & + d2_coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) & + d2_coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) & + d2_coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) d2u ( i , j , b ) = d2_fw ( j ) * ( temp_d2u - d2_af ( j ) * d2u ( i , j - 1 , b )) send_du_e ( i , 1 , b ) = du ( i , n , b ) send_dud_e ( i , 1 , b ) = dud ( i , n , b ) send_d2u_e ( i , 1 , b ) = d2u ( i , n , b ) ! Backward pass of the hybrid algorithm do j = n - 2 , 2 , - 1 du ( i , j , b ) = du ( i , j , b ) - d1_bw ( j ) * du ( i , j + 1 , b ) dud ( i , j , b ) = dud ( i , j , b ) - d1_bw ( j ) * dud ( i , j + 1 , b ) d2u ( i , j , b ) = d2u ( i , j , b ) - d2_bw ( j ) * d2u ( i , j + 1 , b ) end do du ( i , 1 , b ) = d1_last_r * ( du ( i , 1 , b ) - d1_bw ( 1 ) * du ( i , 2 , b )) dud ( i , 1 , b ) = d1_last_r * ( dud ( i , 1 , b ) - d1_bw ( 1 ) * dud ( i , 2 , b )) d2u ( i , 1 , b ) = d2_last_r * ( d2u ( i , 1 , b ) - d2_bw ( 1 ) * d2u ( i , 2 , b )) send_du_s ( i , 1 , b ) = du ( i , 1 , b ) send_dud_s ( i , 1 , b ) = dud ( i , 1 , b ) send_d2u_s ( i , 1 , b ) = d2u ( i , 1 , b ) end subroutine transeq_3fused_dist attributes ( global ) subroutine transeq_3fused_subs ( & r_u , conv , du , dud , d2u , & recv_du_s , recv_du_e , recv_dud_s , recv_dud_e , recv_d2u_s , recv_d2u_e , & d1_sa , d1_sc , d2_sa , d2_sc , n , nu & ) implicit none ! Arguments real ( dp ), device , intent ( out ), dimension (:, :, :) :: r_u real ( dp ), device , intent ( in ), dimension (:, :, :) :: conv , du , dud , d2u real ( dp ), device , intent ( in ), dimension (:, :, :) :: & recv_du_s , recv_du_e , recv_dud_s , recv_dud_e , recv_d2u_s , recv_d2u_e real ( dp ), device , intent ( in ), dimension (:) :: d1_sa , d1_sc , d2_sa , d2_sc integer , value , intent ( in ) :: n real ( dp ), value , intent ( in ) :: nu ! Local variables integer :: i , j , b real ( dp ) :: ur , bl , recp real ( dp ) :: du_temp , dud_temp , d2u_temp real ( dp ) :: du_s , du_e , dud_s , dud_e , d2u_s , d2u_e i = threadIdx % x b = blockIdx % x ! A small trick we do here is valid for symmetric Toeplitz matrices. ! In our case our matrices satisfy this criteria in the (5:n-4) region ! and as long as a rank has around at least 20 entries the assumptions ! we make here are perfectly valid. ! bl is the bottom left entry in the 2x2 matrix ! ur is the upper right entry in the 2x2 matrix ! Start ! At the start we have the 'bl', and assume 'ur' ! first derivative bl = d1_sa ( 1 ) ur = d1_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) du_s = recp * ( du ( i , 1 , b ) - bl * recv_du_s ( i , 1 , b )) dud_s = recp * ( dud ( i , 1 , b ) - bl * recv_dud_s ( i , 1 , b )) ! second derivative bl = d2_sa ( 1 ) ur = d2_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) d2u_s = recp * ( d2u ( i , 1 , b ) - bl * recv_d2u_s ( i , 1 , b )) ! End ! At the end we have the 'ur', and assume 'bl' ! first derivative bl = d1_sc ( n ) ur = d1_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) du_e = recp * ( du ( i , n , b ) - ur * recv_du_e ( i , 1 , b )) dud_e = recp * ( dud ( i , n , b ) - ur * recv_dud_e ( i , 1 , b )) ! second derivative bl = d2_sc ( n ) ur = d2_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) d2u_e = recp * ( d2u ( i , n , b ) - ur * recv_d2u_e ( i , 1 , b )) ! final substitution r_u ( i , 1 , b ) = - 0.5_dp * ( conv ( i , 1 , b ) * du_s + dud_s ) + nu * d2u_s do j = 2 , n - 1 du_temp = ( du ( i , j , b ) - d1_sa ( j ) * du_s - d1_sc ( j ) * du_e ) dud_temp = ( dud ( i , j , b ) - d1_sa ( j ) * dud_s - d1_sc ( j ) * dud_e ) d2u_temp = ( d2u ( i , j , b ) - d2_sa ( j ) * d2u_s - d2_sc ( j ) * d2u_e ) r_u ( i , j , b ) = - 0.5_dp * ( conv ( i , j , b ) * du_temp + dud_temp ) & + nu * d2u_temp end do r_u ( i , n , b ) = - 0.5_dp * ( conv ( i , n , b ) * du_e + dud_e ) + nu * d2u_e end subroutine transeq_3fused_subs end module m_cuda_kernels_dist","tags":"","loc":"sourcefile/distributed.f90.html"},{"title":"poisson_fft.f90 – x3d2","text":"Source Code module m_cuda_poisson_fft use cudafor use cufft use m_allocator , only : field_t use m_common , only : dp use m_poisson_fft , only : poisson_fft_t use m_tdsops , only : dirps_t use m_cuda_allocator , only : cuda_field_t use m_cuda_common , only : SZ use m_cuda_complex , only : reorder_cmplx_x2y_T , reorder_cmplx_y2x_T , & reorder_cmplx_y2z_T , reorder_cmplx_z2y_T , & process_spectral_div_u implicit none type , extends ( poisson_fft_t ) :: cuda_poisson_fft_t !! FFT based Poisson solver !! It can only handle 1D decompositions along z direction. !> Local domain sized arrays to store data in spectral space complex ( dp ), device , pointer , dimension (:) :: c_x_dev , c_y_dev , c_z_dev !> Local domain sized array storing the spectral equivalence constants complex ( dp ), device , allocatable , dimension (:, :, :) :: waves_dev real ( dp ), device , allocatable , dimension (:) :: ax_dev , bx_dev , & ay_dev , by_dev , az_dev , bz_dev real ( dp ), device , allocatable , dimension (:, :, :) :: f_tmp integer :: planD2Zz , planZ2Dz , planZ2Zx , planZ2Zy contains procedure :: fft_forward => fft_forward_cuda procedure :: fft_backward => fft_backward_cuda procedure :: fft_postprocess => fft_postprocess_cuda end type cuda_poisson_fft_t interface cuda_poisson_fft_t module procedure init end interface cuda_poisson_fft_t private :: init contains function init ( xdirps , ydirps , zdirps ) result ( poisson_fft ) implicit none class ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps type ( cuda_poisson_fft_t ) :: poisson_fft integer :: nx , ny , nz integer :: ierrfft integer ( int_ptr_kind ()) :: worksize call poisson_fft % base_init ( xdirps , ydirps , zdirps , SZ ) nx = poisson_fft % nx ; ny = poisson_fft % ny ; nz = poisson_fft % nz allocate ( poisson_fft % waves_dev ( SZ , nx , ( ny * ( nz / 2 + 1 )) / SZ )) poisson_fft % waves_dev = poisson_fft % waves allocate ( poisson_fft % ax_dev ( nx ), poisson_fft % bx_dev ( nx )) allocate ( poisson_fft % ay_dev ( ny ), poisson_fft % by_dev ( ny )) allocate ( poisson_fft % az_dev ( nz ), poisson_fft % bz_dev ( nz )) poisson_fft % ax_dev = poisson_fft % ax ; poisson_fft % bx_dev = poisson_fft % bx poisson_fft % ay_dev = poisson_fft % ay ; poisson_fft % by_dev = poisson_fft % by poisson_fft % az_dev = poisson_fft % az ; poisson_fft % bz_dev = poisson_fft % bz allocate ( poisson_fft % c_x_dev ( nx * ny * ( nz / 2 + 1 ))) allocate ( poisson_fft % c_y_dev ( nx * ny * ( nz / 2 + 1 ))) allocate ( poisson_fft % c_z_dev ( nx * ny * ( nz / 2 + 1 ))) ! We can't currently ask allocator to pass us an array with ! exact shape we want, so we allocate an extra array here. ! This will be removed when allocator is fixed. allocate ( poisson_fft % f_tmp ( nz , SZ , nx * ny / SZ )) ! set cufft plans ierrfft = cufftCreate ( poisson_fft % planD2Zz ) ierrfft = cufftMakePlanMany ( poisson_fft % planD2Zz , 1 , nz , & nz , 1 , nz , nz / 2 + 1 , 1 , nz / 2 + 1 , & CUFFT_D2Z , nx * ny , worksize ) ierrfft = cufftSetWorkArea ( poisson_fft % planD2Zz , poisson_fft % c_x_dev ) ierrfft = cufftCreate ( poisson_fft % planZ2Dz ) ierrfft = cufftMakePlanMany ( poisson_fft % planZ2Dz , 1 , nz , & nz / 2 + 1 , 1 , nz / 2 + 1 , nz , 1 , nz , & CUFFT_Z2D , nx * ny , worksize ) ierrfft = cufftSetWorkArea ( poisson_fft % planZ2Dz , poisson_fft % c_x_dev ) ierrfft = cufftCreate ( poisson_fft % planZ2Zy ) ierrfft = cufftMakePlanMany ( poisson_fft % planZ2Zy , 1 , ny , & ny , 1 , ny , ny , 1 , ny , & CUFFT_Z2Z , nx * ( nz / 2 + 1 ), worksize ) ierrfft = cufftSetWorkArea ( poisson_fft % planZ2Zy , poisson_fft % c_x_dev ) ierrfft = cufftCreate ( poisson_fft % planZ2Zx ) ierrfft = cufftMakePlanMany ( poisson_fft % planZ2Zx , 1 , nx , & nx , 1 , nx , nx , 1 , nx , & CUFFT_Z2Z , ny * ( nz / 2 + 1 ), worksize ) ierrfft = cufftSetWorkArea ( poisson_fft % planZ2Zx , poisson_fft % c_y_dev ) end function init subroutine fft_forward_cuda ( self , f ) implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f real ( dp ), device , pointer , dimension (:, :, :) :: f_dev complex ( dp ), device , dimension (:, :, :), pointer :: c_x_ptr , c_y_ptr , & c_z_ptr type ( dim3 ) :: blocks , threads integer :: ierrfft select type ( f ); type is ( cuda_field_t ); f_dev => f % data_d ; end select ! First reorder f into cartesian-like data structure blocks = dim3 ( self % nz / SZ , self % nx * self % ny / SZ , 1 ) threads = dim3 ( SZ , SZ , 1 ) call reshapeDSF <<< blocks , threads >>> ( self % f_tmp , f_dev ) ! Forward FFT transform in z from real to complex ierrfft = cufftExecD2Z ( self % planD2Zz , self % f_tmp , self % c_z_dev ) ! Reorder from z to y blocks = dim3 ( self % nz / 2 / SZ + 1 , self % ny / SZ , self % nx ) threads = dim3 ( SZ , SZ , 1 ) c_y_ptr ( 1 : self % ny , 1 : SZ , 1 :( self % nx * ( self % nz / 2 + 1 )) / SZ ) => self % c_y_dev c_z_ptr ( 1 : self % nz / 2 + 1 , 1 : SZ , 1 : self % nx * self % ny / SZ ) => self % c_z_dev call reorder_cmplx_z2y_T <<< blocks , threads >>> ( c_y_ptr , c_z_ptr , & self % nx , self % nz / 2 + 1 ) ! In-place forward FFT in y ierrfft = cufftExecZ2Z ( self % planZ2Zy , self % c_y_dev , self % c_y_dev , & CUFFT_FORWARD ) ! Reorder from y to x blocks = dim3 ( self % nx / SZ , self % ny / SZ , self % nz / 2 + 1 ) threads = dim3 ( SZ , SZ , 1 ) c_x_ptr ( 1 : self % nx , 1 : SZ , 1 :( self % ny * ( self % nz / 2 + 1 )) / SZ ) => self % c_x_dev c_y_ptr ( 1 : self % ny , 1 : SZ , 1 :( self % nx * ( self % nz / 2 + 1 )) / SZ ) => self % c_y_dev call reorder_cmplx_y2x_T <<< blocks , threads >>> ( c_x_ptr , c_y_ptr , & self % nz / 2 + 1 ) ! In-place forward FFT in x ierrfft = cufftExecZ2Z ( self % planZ2Zx , self % c_x_dev , self % c_x_dev , & CUFFT_FORWARD ) end subroutine fft_forward_cuda subroutine fft_backward_cuda ( self , f ) implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), device , pointer , dimension (:, :, :) :: f_dev complex ( dp ), device , dimension (:, :, :), pointer :: c_x_ptr , c_y_ptr , & c_z_ptr type ( dim3 ) :: blocks , threads integer :: ierrfft select type ( f ); type is ( cuda_field_t ); f_dev => f % data_d ; end select ! In-place backward FFT in x ierrfft = cufftExecZ2Z ( self % planZ2Zx , self % c_x_dev , self % c_x_dev , & CUFFT_INVERSE ) ! Reorder from x to y blocks = dim3 ( self % nx / SZ , self % ny / SZ , self % nz / 2 + 1 ) threads = dim3 ( SZ , SZ , 1 ) c_x_ptr ( 1 : self % nx , 1 : SZ , 1 :( self % ny * ( self % nz / 2 + 1 )) / SZ ) => self % c_x_dev c_y_ptr ( 1 : self % ny , 1 : SZ , 1 :( self % nx * ( self % nz / 2 + 1 )) / SZ ) => self % c_y_dev call reorder_cmplx_x2y_T <<< blocks , threads >>> ( c_y_ptr , c_x_ptr , & self % nz / 2 + 1 ) ! In-place backward FFT in y ierrfft = cufftExecZ2Z ( self % planZ2Zy , self % c_y_dev , self % c_y_dev , & CUFFT_INVERSE ) ! Reorder from y to z blocks = dim3 ( self % nz / 2 / SZ + 1 , self % ny / SZ , self % nx ) threads = dim3 ( SZ , SZ , 1 ) c_y_ptr ( 1 : self % ny , 1 : SZ , 1 :( self % nx * ( self % nz / 2 + 1 )) / SZ ) => self % c_y_dev c_z_ptr ( 1 : self % nz / 2 + 1 , 1 : SZ , 1 : self % nx * self % ny / SZ ) => self % c_z_dev call reorder_cmplx_y2z_T <<< blocks , threads >>> ( c_z_ptr , c_y_ptr , & self % nx , self % nz / 2 + 1 ) ! Backward FFT transform in z from complex to real ierrfft = cufftExecZ2D ( self % planZ2Dz , self % c_z_dev , self % f_tmp ) ! Finally reorder f back into our specialist data structure blocks = dim3 ( self % nz / SZ , self % nx * self % ny / SZ , 1 ) threads = dim3 ( SZ , SZ , 1 ) call reshapeDSB <<< blocks , threads >>> ( f_dev , self % f_tmp ) end subroutine fft_backward_cuda subroutine fft_postprocess_cuda ( self ) implicit none class ( cuda_poisson_fft_t ) :: self complex ( dp ), device , dimension (:, :, :), pointer :: c_dev , c_x_ptr type ( dim3 ) :: blocks , threads ! Get some complex array pointers with right shape c_x_ptr ( 1 : self % nx , 1 : SZ , 1 :( self % ny * ( self % nz / 2 + 1 )) / SZ ) => self % c_x_dev c_dev ( 1 : SZ , 1 : self % nx , 1 :( self % ny * ( self % nz / 2 + 1 )) / SZ ) => self % c_y_dev ! Reshape from cartesian-like to our specialist data structure blocks = dim3 ( self % nx / SZ , ( self % ny * ( self % nz / 2 + 1 )) / SZ , 1 ) threads = dim3 ( SZ , SZ , 1 ) call reshapeCDSB <<< blocks , threads >>> ( c_dev , c_x_ptr ) ! Postprocess blocks = dim3 (( self % ny * ( self % nz / 2 + 1 )) / SZ , 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call process_spectral_div_u <<< blocks , threads >>> ( & c_dev , self % waves_dev , self % nx , self % ny , self % nz , & self % ax_dev , self % bx_dev , self % ay_dev , self % by_dev , & self % az_dev , self % bz_dev & ) ! Reshape from our specialist data structure to cartesian-like blocks = dim3 ( self % nx / SZ , ( self % ny * ( self % nz / 2 + 1 )) / SZ , 1 ) threads = dim3 ( SZ , SZ , 1 ) call reshapeCDSF <<< blocks , threads >>> ( c_x_ptr , c_dev ) end subroutine fft_postprocess_cuda end module m_cuda_poisson_fft","tags":"","loc":"sourcefile/poisson_fft.f90~3.html"},{"title":"allocator.f90 – x3d2","text":"Source Code module m_allocator use m_common , only : dp implicit none type :: allocator_t !! An instance of type allocator_t is responsible for the !! maintenance of a linked list of instances of equal size !! [[m_allocator(module):field_t(type)]] objects: !! !! ``` !!       ---- ---- ----     ---- ---- ---- !! ...-->|id=1|data|next|-->|id=0|data|next|-->null() !!       ---- ---- ----     ---- ---- ---- !! ``` !! !! the last block's `next` pointer being non associated. !! !! User code can request access to a memory block by using the !! type bound procedure !! [[m_allocator(module):get_block(function)]].  If the list is !! not empty, a pointer to the first block on the list is !! returned and the block is detached from the list.  If the list !! is empty (i.e. all initially allocated blocks are currently !! referenced to) then a new block is allocated before a pointer !! to it is returned. !! !! In order to reuse memory it is important that user code !! release blocks when they are not needed anymore.  This is done !! by calling the type bound procedure !! [[m_allocator(module):release_block(subroutine)]].  The !! released block is then pushed in front of the block list. integer :: dims ( 3 ) !> The id for the next allocated block.  This counter is !> incremented each time a new block is allocated. integer :: next_id = 0 !> The pointer to the first block on the list.  Non associated if !> the list is empty ! TODO: Rename first to head class ( field_t ), pointer :: first => null () contains procedure :: get_block procedure :: release_block procedure :: create_block procedure :: get_block_ids procedure :: destroy end type allocator_t type :: field_t !! Memory block type holding both a 3D data field and a pointer !! to the next block.  The `field_t` type also holds a integer !! `refcount` that counts the number of references to this !! field.  User code is currently responsible for incrementing !! the reference count. class ( field_t ), pointer :: next real ( dp ), allocatable :: data (:, :, :) integer :: refcount = 0 integer :: id !! An integer identifying the memory block. end type field_t interface field_t module procedure field_constructor end interface field_t type :: flist_t class ( field_t ), pointer :: ptr end type flist_t contains function field_constructor ( dims , next , id ) result ( m ) integer , intent ( in ) :: dims ( 3 ), id type ( field_t ), pointer , intent ( in ) :: next type ( field_t ) :: m allocate ( m % data ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) m % refcount = 0 m % next => next m % id = id end function field_constructor function create_block ( self , next ) result ( ptr ) !! Allocate memory for a new block and return a pointer to a new !! [[m_allocator(module):field_t(type)]] object. class ( allocator_t ), intent ( inout ) :: self type ( field_t ), pointer , intent ( in ) :: next type ( field_t ), pointer :: newblock class ( field_t ), pointer :: ptr self % next_id = self % next_id + 1 allocate ( newblock ) newblock = field_t ( self % dims , next , id = self % next_id ) ptr => newblock end function create_block function get_block ( self ) result ( handle ) !! Return a pointer to the first available memory block, i.e. the !! current head of the block list.  If the list is empty, allocate !! a new block with [[m_allocator(module):create_block(function)]] !! first. !! !! Example !! ``` !! f%data => get_block() !! ``` class ( allocator_t ), intent ( inout ) :: self class ( field_t ), pointer :: handle ! If the list is empty, allocate a new block before returning a ! pointer to it. if (. not . associated ( self % first )) then ! Construct a field_t. This effectively allocates ! storage space. self % first => self % create_block ( next = self % first ) end if handle => self % first self % first => self % first % next ! 2nd block becomes head block handle % next => null () ! Detach ex-head block from the block list end function get_block subroutine release_block ( self , handle ) !! Release memory block pointed to by HANDLE to the block list. !! It is pushed to the front of the block list, in other words it !! is made the head block. class ( allocator_t ), intent ( inout ) :: self class ( field_t ), pointer :: handle handle % next => self % first self % first => handle end subroutine release_block subroutine destroy ( self ) !! Go through the block list from head to tail, deallocating each !! memory block in turn.  Deallocation of a !! [[m_allocator(module):field_t(type)]] object automatically !! deallocates its internal allocatable !! [[field_t(type):data(variable)]] array. class ( allocator_t ), intent ( inout ) :: self type ( field_t ), pointer :: current do if (. not . associated ( self % first )) exit current => self % first self % first => self % first % next deallocate ( current ) self % next_id = self % next_id - 1 end do end subroutine destroy function get_block_ids ( self ) !! Utility function that returns a array made of the `id` of the !! block currently in the block list.  Return the array [0] if !! block list is empty. ! TODO: Block indices should start at 1 or return [-1] in case of ! empty block list. class ( allocator_t ), intent ( inout ) :: self integer , allocatable :: get_block_ids (:) class ( field_t ), pointer :: current integer :: i current => self % first if (. not . associated ( current )) then get_block_ids = [ 0 ] else i = current % id get_block_ids = [ current % id ] do if (. not . associated ( current % next )) exit i = current % next % id get_block_ids = [ get_block_ids , current % next % id ] current => current % next end do end if end function get_block_ids end module m_allocator","tags":"","loc":"sourcefile/allocator.f90~2.html"},{"title":"sendrecv.f90 – x3d2","text":"Source Code module m_cuda_sendrecv use cudafor use mpi use m_common , only : dp implicit none contains subroutine sendrecv_fields ( f_recv_s , f_recv_e , f_send_s , f_send_e , & n_data , nproc , prev , next ) implicit none real ( dp ), device , dimension (:, :, :), intent ( out ) :: f_recv_s , f_recv_e real ( dp ), device , dimension (:, :, :), intent ( in ) :: f_send_s , f_send_e integer , intent ( in ) :: n_data , nproc , prev , next integer :: req ( 4 ), err ( 4 ), ierr , tag = 1234 if ( nproc == 1 ) then f_recv_s = f_send_e f_recv_e = f_send_s else call MPI_Isend ( f_send_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 1 ), err ( 1 )) call MPI_Irecv ( f_recv_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 2 ), err ( 2 )) call MPI_Isend ( f_send_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 3 ), err ( 3 )) call MPI_Irecv ( f_recv_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 4 ), err ( 4 )) call MPI_Waitall ( 4 , req , MPI_STATUSES_IGNORE , ierr ) end if end subroutine sendrecv_fields subroutine sendrecv_3fields ( & f1_recv_s , f1_recv_e , f2_recv_s , f2_recv_e , f3_recv_s , f3_recv_e , & f1_send_s , f1_send_e , f2_send_s , f2_send_e , f3_send_s , f3_send_e , & n_data , nproc , prev , next & ) implicit none real ( dp ), device , dimension (:, :, :), intent ( out ) :: & f1_recv_s , f1_recv_e , f2_recv_s , f2_recv_e , f3_recv_s , f3_recv_e real ( dp ), device , dimension (:, :, :), intent ( in ) :: & f1_send_s , f1_send_e , f2_send_s , f2_send_e , f3_send_s , f3_send_e integer , intent ( in ) :: n_data , nproc , prev , next integer :: req ( 12 ), err ( 12 ), ierr , tag = 1234 if ( nproc == 1 ) then f1_recv_s = f1_send_e f1_recv_e = f1_send_s f2_recv_s = f2_send_e f2_recv_e = f2_send_s f3_recv_s = f3_send_e f3_recv_e = f3_send_s else call MPI_Isend ( f1_send_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 1 ), err ( 1 )) call MPI_Irecv ( f1_recv_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 2 ), err ( 2 )) call MPI_Isend ( f1_send_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 3 ), err ( 3 )) call MPI_Irecv ( f1_recv_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 4 ), err ( 4 )) call MPI_Isend ( f2_send_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 5 ), err ( 5 )) call MPI_Irecv ( f2_recv_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 6 ), err ( 6 )) call MPI_Isend ( f2_send_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 7 ), err ( 7 )) call MPI_Irecv ( f2_recv_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 8 ), err ( 8 )) call MPI_Isend ( f3_send_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 9 ), err ( 9 )) call MPI_Irecv ( f3_recv_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 10 ), err ( 10 )) call MPI_Isend ( f3_send_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 11 ), err ( 11 )) call MPI_Irecv ( f3_recv_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 12 ), err ( 12 )) call MPI_Waitall ( 12 , req , MPI_STATUSES_IGNORE , ierr ) end if end subroutine sendrecv_3fields end module m_cuda_sendrecv","tags":"","loc":"sourcefile/sendrecv.f90.html"},{"title":"xcompact.f90 – x3d2","text":"Source Code program xcompact use mpi use m_allocator use m_base_backend use m_common , only : pi , globs_t , set_pprev_pnext , & POISSON_SOLVER_FFT , POISSON_SOLVER_CG use m_solver , only : solver_t use m_time_integrator , only : time_intg_t use m_tdsops , only : tdsops_t #ifdef CUDA use m_cuda_allocator use m_cuda_backend use m_cuda_common , only : SZ use m_cuda_tdsops , only : cuda_tdsops_t #else use m_omp_backend use m_omp_common , only : SZ #endif implicit none type ( globs_t ) :: globs class ( base_backend_t ), pointer :: backend class ( allocator_t ), pointer :: allocator type ( solver_t ) :: solver type ( time_intg_t ) :: time_integrator type ( dirps_t ) :: xdirps , ydirps , zdirps #ifdef CUDA type ( cuda_backend_t ), target :: cuda_backend type ( cuda_allocator_t ), target :: cuda_allocator integer :: ndevs , devnum #else type ( omp_backend_t ), target :: omp_backend type ( allocator_t ), target :: omp_allocator #endif real ( dp ), allocatable , dimension (:, :, :) :: u , v , w real ( dp ) :: t_start , t_end integer :: nrank , nproc , ierr call MPI_Init ( ierr ) call MPI_Comm_rank ( MPI_COMM_WORLD , nrank , ierr ) call MPI_Comm_size ( MPI_COMM_WORLD , nproc , ierr ) if ( nrank == 0 ) print * , 'Parallel run with' , nproc , 'ranks' #ifdef CUDA ierr = cudaGetDeviceCount ( ndevs ) ierr = cudaSetDevice ( mod ( nrank , ndevs )) ! round-robin ierr = cudaGetDevice ( devnum ) #endif ! read L_x/y/z from the input file globs % Lx = 2 * pi ; globs % Ly = 2 * pi ; globs % Lz = 2 * pi xdirps % L = globs % Lx ; ydirps % L = globs % Ly ; zdirps % L = globs % Lz ! read ns from the input file globs % nx = 256 ; globs % ny = 256 ; globs % nz = 256 globs % dt = 0.001_dp globs % nu = 1._dp / 160 0._dp globs % n_iters = 20000 globs % n_output = 100 ! set nprocs based on run time arguments globs % nproc_x = 1 ; globs % nproc_y = 1 ; globs % nproc_z = 1 globs % poisson_solver_type = POISSON_SOLVER_FFT ! Lets allow a 1D decomposition for the moment !globs%nproc_x = nproc xdirps % nproc = globs % nproc_x ydirps % nproc = globs % nproc_y zdirps % nproc = globs % nproc_z ! Better if we move this somewhere else ! Set the pprev and pnext for each rank call set_pprev_pnext ( & xdirps % pprev , xdirps % pnext , & ydirps % pprev , ydirps % pnext , & zdirps % pprev , zdirps % pnext , & xdirps % nproc , ydirps % nproc , zdirps % nproc , nrank & ) ! lets assume simple cases for now globs % nx_loc = globs % nx / globs % nproc_x globs % ny_loc = globs % ny / globs % nproc_y globs % nz_loc = globs % nz / globs % nproc_z globs % n_groups_x = globs % ny_loc * globs % nz_loc / SZ globs % n_groups_y = globs % nx_loc * globs % nz_loc / SZ globs % n_groups_z = globs % nx_loc * globs % ny_loc / SZ globs % dx = globs % Lx / globs % nx globs % dy = globs % Ly / globs % ny globs % dz = globs % Lz / globs % nz xdirps % d = globs % dx ; ydirps % d = globs % dy ; zdirps % d = globs % dz xdirps % n = globs % nx_loc ydirps % n = globs % ny_loc zdirps % n = globs % nz_loc xdirps % n_blocks = globs % n_groups_x ydirps % n_blocks = globs % n_groups_y zdirps % n_blocks = globs % n_groups_z #ifdef CUDA cuda_allocator = cuda_allocator_t ([ SZ , globs % nx_loc , globs % n_groups_x ]) allocator => cuda_allocator print * , 'CUDA allocator instantiated' cuda_backend = cuda_backend_t ( globs , allocator ) backend => cuda_backend print * , 'CUDA backend instantiated' #else omp_allocator = allocator_t ([ SZ , globs % nx_loc , globs % n_groups_x ]) allocator => omp_allocator print * , 'OpenMP allocator instantiated' omp_backend = omp_backend_t ( globs , allocator ) backend => omp_backend print * , 'OpenMP backend instantiated' #endif allocate ( u ( SZ , globs % nx_loc , globs % n_groups_x )) allocate ( v ( SZ , globs % nx_loc , globs % n_groups_x )) allocate ( w ( SZ , globs % nx_loc , globs % n_groups_x )) time_integrator = time_intg_t ( allocator = allocator , backend = backend ) print * , 'time integrator instantiated' solver = solver_t ( backend , time_integrator , xdirps , ydirps , zdirps , globs ) print * , 'solver instantiated' call cpu_time ( t_start ) call solver % run ( u , v , w ) call cpu_time ( t_end ) print * , 'Time: ' , t_end - t_start print * , 'norms' , norm2 ( u ), norm2 ( v ), norm2 ( w ) call MPI_Finalize ( ierr ) end program xcompact","tags":"","loc":"sourcefile/xcompact.f90.html"},{"title":"common.f90 – x3d2","text":"Source Code module m_common implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( dp ), parameter :: pi = 4 * atan ( 1.0_dp ) integer , parameter :: RDR_X2Y = 12 , RDR_X2Z = 13 , RDR_Y2X = 21 , & RDR_Y2Z = 23 , RDR_Z2X = 31 , RDR_Z2Y = 32 integer , parameter :: POISSON_SOLVER_FFT = 0 , POISSON_SOLVER_CG = 1 type :: globs_t integer :: nx , ny , nz integer :: nx_loc , ny_loc , nz_loc integer :: n_groups_x , n_groups_y , n_groups_z real ( dp ) :: Lx , Ly , Lz real ( dp ) :: dx , dy , dz real ( dp ) :: nu , dt integer :: n_iters , n_output integer :: nproc_x = 1 , nproc_y = 1 , nproc_z = 1 character ( len = 20 ) :: BC_x_s , BC_x_e , BC_y_s , BC_y_e , BC_z_s , BC_z_e integer :: poisson_solver_type end type globs_t contains subroutine set_pprev_pnext ( xprev , xnext , yprev , ynext , zprev , znext , & xnproc , ynproc , znproc , nrank ) implicit none integer , intent ( out ) :: xprev , xnext , yprev , ynext , zprev , znext integer , intent ( in ) :: xnproc , ynproc , znproc , nrank integer :: ix , iy , iz ix = modulo ( nrank , xnproc ) iy = modulo (( nrank - ix ) / xnproc , ynproc ) iz = ( nrank - ix - iy * xnproc ) / ( xnproc * ynproc ) ! nrank == ix + iy*xnproc + iz*xnproc*ynproc ! prev and next in x direction if ( ix == 0 ) then xprev = nrank + ( xnproc - 1 ) else xprev = nrank - 1 end if if ( ix == xnproc - 1 ) then xnext = nrank - ( xnproc - 1 ) else xnext = nrank + 1 end if ! prev and next in y direction if ( iy == 0 ) then yprev = nrank + ( xnproc * ( ynproc - 1 )) else yprev = nrank - xnproc end if if ( iy == ynproc - 1 ) then ynext = nrank - ( xnproc * ( ynproc - 1 )) else ynext = nrank + xnproc end if ! prev and next in z direction if ( iz == 0 ) then zprev = nrank + ( xnproc * ynproc * ( znproc - 1 )) else zprev = nrank - xnproc * ynproc end if if ( iz == znproc - 1 ) then znext = nrank - ( xnproc * ynproc * ( znproc - 1 )) else znext = nrank + xnproc * ynproc end if end subroutine set_pprev_pnext end module m_common","tags":"","loc":"sourcefile/common.f90~3.html"},{"title":"exec_dist.f90 – x3d2","text":"Source Code module m_omp_exec_dist use mpi use m_common , only : dp use m_omp_common , only : SZ use m_omp_kernels_dist , only : der_univ_dist , der_univ_subs use m_tdsops , only : tdsops_t use m_omp_sendrecv , only : sendrecv_fields implicit none contains subroutine exec_dist_tds_compact ( & du , u , u_recv_s , u_recv_e , du_send_s , du_send_e , du_recv_s , du_recv_e , & tdsops , nproc , pprev , pnext , n_block & ) implicit none ! du = d(u) real ( dp ), dimension (:, :, :), intent ( out ) :: du real ( dp ), dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care about the data they pass back real ( dp ), dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e type ( tdsops_t ), intent ( in ) :: tdsops integer , intent ( in ) :: nproc , pprev , pnext integer , intent ( in ) :: n_block integer :: n_data integer :: k n_data = SZ * n_block !$omp parallel do do k = 1 , n_block call der_univ_dist ( & du (:, :, k ), du_send_s (:, :, k ), du_send_e (:, :, k ), u (:, :, k ), & u_recv_s (:, :, k ), u_recv_e (:, :, k ), & tdsops % coeffs_s , tdsops % coeffs_e , tdsops % coeffs , tdsops % n , & tdsops % dist_fw , tdsops % dist_bw , tdsops % dist_af & ) end do !$omp end parallel do ! halo exchange for 2x2 systems call sendrecv_fields ( du_recv_s , du_recv_e , du_send_s , du_send_e , & n_data , nproc , pprev , pnext ) !$omp parallel do do k = 1 , n_block call der_univ_subs ( du (:, :, k ), & du_recv_s (:, :, k ), du_recv_e (:, :, k ), & tdsops % n , tdsops % dist_sa , tdsops % dist_sc ) end do !$omp end parallel do end subroutine exec_dist_tds_compact subroutine exec_dist_transeq_compact (& rhs , du , dud , d2u , & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e , & u , u_recv_s , u_recv_e , & v , v_recv_s , v_recv_e , & tdsops_du , tdsops_dud , tdsops_d2u , nu , nproc , pprev , pnext , n_block ) implicit none ! du = d(u) real ( dp ), dimension (:, :, :), intent ( out ) :: rhs , du , dud , d2u ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care about the data they pass back real ( dp ), dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e real ( dp ), dimension (:, :, :), intent ( out ) :: & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e real ( dp ), dimension (:, :, :), intent ( out ) :: & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e real ( dp ), dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e real ( dp ), dimension (:, :, :), intent ( in ) :: v , v_recv_s , v_recv_e type ( tdsops_t ), intent ( in ) :: tdsops_du , tdsops_dud , tdsops_d2u real ( dp ), dimension (:, :), allocatable :: ud , ud_recv_s , ud_recv_e real ( dp ) :: nu integer , intent ( in ) :: nproc , pprev , pnext integer , intent ( in ) :: n_block integer :: n_data , n_halo integer :: k , i , j , n ! TODO: don't hardcode n_halo n_halo = 4 n = tdsops_d2u % n n_data = SZ * n_block allocate ( ud ( SZ , n )) allocate ( ud_recv_e ( SZ , n_halo )) allocate ( ud_recv_s ( SZ , n_halo )) !$omp parallel do private(ud, ud_recv_e, ud_recv_s) do k = 1 , n_block call der_univ_dist ( & du (:, :, k ), du_send_s (:, :, k ), du_send_e (:, :, k ), u (:, :, k ), & u_recv_s (:, :, k ), u_recv_e (:, :, k ), & tdsops_du % coeffs_s , tdsops_du % coeffs_e , tdsops_du % coeffs , tdsops_du % n , & tdsops_du % dist_fw , tdsops_du % dist_bw , tdsops_du % dist_af & ) call der_univ_dist ( & d2u (:, :, k ), d2u_send_s (:, :, k ), d2u_send_e (:, :, k ), u (:, :, k ), & u_recv_s (:, :, k ), u_recv_e (:, :, k ), & tdsops_d2u % coeffs_s , tdsops_d2u % coeffs_e , tdsops_d2u % coeffs , tdsops_d2u % n , & tdsops_d2u % dist_fw , tdsops_d2u % dist_bw , tdsops_d2u % dist_af & ) ! Handle dud by locally generating u*v do j = 1 , n !$omp simd do i = 1 , SZ ud ( i , j ) = u ( i , j , k ) * v ( i , j , k ) end do !$omp end simd end do do j = 1 , n_halo !$omp simd do i = 1 , SZ ud_recv_s ( i , j ) = u_recv_s ( i , j , k ) * v_recv_s ( i , j , k ) ud_recv_e ( i , j ) = u_recv_e ( i , j , k ) * v_recv_e ( i , j , k ) end do !$omp end simd end do call der_univ_dist ( & dud (:, :, k ), dud_send_s (:, :, k ), dud_send_e (:, :, k ), ud (:, :), & ud_recv_s (:, :), ud_recv_e (:, :), & tdsops_dud % coeffs_s , tdsops_dud % coeffs_e , tdsops_dud % coeffs , tdsops_dud % n , & tdsops_dud % dist_fw , tdsops_dud % dist_bw , tdsops_dud % dist_af & ) end do !$omp end parallel do ! halo exchange for 2x2 systems call sendrecv_fields ( du_recv_s , du_recv_e , du_send_s , du_send_e , & n_data , nproc , pprev , pnext ) call sendrecv_fields ( dud_recv_s , dud_recv_e , dud_send_s , dud_send_e , & n_data , nproc , pprev , pnext ) call sendrecv_fields ( d2u_recv_s , d2u_recv_e , d2u_send_s , d2u_send_e , & n_data , nproc , pprev , pnext ) !$omp parallel do do k = 1 , n_block call der_univ_subs ( du (:, :, k ), & du_recv_s (:, :, k ), du_recv_e (:, :, k ), & tdsops_du % n , tdsops_du % dist_sa , tdsops_du % dist_sc ) call der_univ_subs ( dud (:, :, k ), & dud_recv_s (:, :, k ), dud_recv_e (:, :, k ), & tdsops_dud % n , tdsops_dud % dist_sa , tdsops_dud % dist_sc ) call der_univ_subs ( d2u (:, :, k ), & d2u_recv_s (:, :, k ), d2u_recv_e (:, :, k ), & tdsops_d2u % n , tdsops_d2u % dist_sa , tdsops_d2u % dist_sc ) do j = 1 , n !$omp simd do i = 1 , SZ rhs ( i , j , k ) = - 0.5_dp * ( v ( i , j , k ) * du ( i , j , k ) + dud ( i , j , k )) + nu * d2u ( i , j , k ) end do !$omp end simd end do end do !$omp end parallel do end subroutine exec_dist_transeq_compact end module m_omp_exec_dist","tags":"","loc":"sourcefile/exec_dist.f90~2.html"},{"title":"solver.f90 – x3d2","text":"Source Code module m_solver use m_allocator , only : allocator_t , field_t use m_base_backend , only : base_backend_t use m_common , only : dp , globs_t , & RDR_X2Y , RDR_X2Z , RDR_Y2X , RDR_Y2Z , RDR_Z2X , RDR_Z2Y , & POISSON_SOLVER_FFT , POISSON_SOLVER_CG use m_tdsops , only : tdsops_t , dirps_t use m_time_integrator , only : time_intg_t implicit none type :: solver_t !! solver class defines the Incompact3D algorithm at a very high level. !! !! Procedures defined here that are part of the Incompact3D algorithm !! are: transeq, divergence, poisson, and gradient. !! !! The operations these high level procedures require are provided by !! the relavant backend implementations. !! !! transeq procedure obtains the derivations in x, y, and z directions !! using the transeq_x, transeq_y, and transeq_z operations provided by !! the backend. !! There are two different algorithms available for this operation, a !! distributed algorithm and the Thomas algorithm. At the solver class !! level it isn't known which algorithm will be executed, that is decided !! at run time and therefore backend implementations are responsible for !! executing the right subroutines. !! !! Allocator is responsible from giving us a field sized array when !! requested. For example, when the derivations in x direction are !! completed and we are ready for the y directional derivatives, we need !! three fields to reorder and store the velocities in y direction. Also, !! we need three more fields for storing the results, and the get_block !! method of the allocator is used to arrange all these memory !! assignments. Later, when a field is no more required, release_block !! method of the allocator can be used to make this field available !! for later use. real ( dp ) :: dt , nu integer :: n_iters , n_output class ( field_t ), pointer :: u , v , w class ( base_backend_t ), pointer :: backend class ( dirps_t ), pointer :: xdirps , ydirps , zdirps class ( time_intg_t ), pointer :: time_integrator procedure ( poisson_solver ), pointer :: poisson => null () contains procedure :: transeq procedure :: divergence_v2p procedure :: gradient_p2v procedure :: curl procedure :: output procedure :: run end type solver_t abstract interface subroutine poisson_solver ( self , pressure , div_u ) import :: solver_t import :: field_t implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: pressure class ( field_t ), intent ( in ) :: div_u end subroutine poisson_solver end interface interface solver_t module procedure init end interface solver_t contains function init ( backend , time_integrator , xdirps , ydirps , zdirps , globs ) & result ( solver ) implicit none class ( base_backend_t ), target , intent ( inout ) :: backend class ( time_intg_t ), target , intent ( inout ) :: time_integrator class ( dirps_t ), target , intent ( inout ) :: xdirps , ydirps , zdirps class ( globs_t ), intent ( in ) :: globs type ( solver_t ) :: solver real ( dp ), allocatable , dimension (:, :, :) :: u_init , v_init , w_init integer :: dims ( 3 ) real ( dp ) :: x , y , z integer :: nx , ny , nz , i , j , b , ka , kb , ix , iy , iz , sz solver % backend => backend solver % time_integrator => time_integrator solver % xdirps => xdirps solver % ydirps => ydirps solver % zdirps => zdirps solver % u => solver % backend % allocator % get_block () solver % v => solver % backend % allocator % get_block () solver % w => solver % backend % allocator % get_block () ! Set initial conditions dims (:) = solver % backend % allocator % dims (:) allocate ( u_init ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) allocate ( v_init ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) allocate ( w_init ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) solver % dt = globs % dt solver % backend % nu = globs % nu solver % n_iters = globs % n_iters solver % n_output = globs % n_output sz = dims ( 1 ) nx = globs % nx_loc ; ny = globs % ny_loc ; nz = globs % nz_loc do ka = 1 , nz do kb = 1 , ny / sz do j = 1 , nx do i = 1 , sz ! Mapping to ix, iy, iz depends on global group numbering ix = j ; iy = ( kb - 1 ) * sz + i ; iz = ka x = ( ix - 1 ) * globs % dx y = ( iy - 1 ) * globs % dy z = ( iz - 1 ) * globs % dz b = ka + ( kb - 1 ) * xdirps % n u_init ( i , j , b ) = sin ( x ) * cos ( y ) * cos ( z ) v_init ( i , j , b ) =- cos ( x ) * sin ( y ) * cos ( z ) w_init ( i , j , b ) = 0 end do end do end do end do call solver % backend % set_field ( solver % u , u_init ) call solver % backend % set_field ( solver % v , v_init ) call solver % backend % set_field ( solver % w , w_init ) deallocate ( u_init , v_init , w_init ) print * , 'initial conditions are set' ! Allocate and set the tdsops call allocate_tdsops ( solver % xdirps , nx , globs % dx , solver % backend ) call allocate_tdsops ( solver % ydirps , ny , globs % dy , solver % backend ) call allocate_tdsops ( solver % zdirps , nz , globs % dz , solver % backend ) select case ( globs % poisson_solver_type ) case ( POISSON_SOLVER_FFT ) print * , 'Poisson solver: FFT' call solver % backend % init_poisson_fft ( xdirps , ydirps , zdirps ) solver % poisson => poisson_fft case ( POISSON_SOLVER_CG ) print * , 'Poisson solver: CG, not yet implemented' solver % poisson => poisson_cg end select end function init subroutine allocate_tdsops ( dirps , nx , dx , backend ) class ( dirps_t ), intent ( inout ) :: dirps real ( dp ), intent ( in ) :: dx integer , intent ( in ) :: nx class ( base_backend_t ), intent ( in ) :: backend call backend % alloc_tdsops ( dirps % der1st , nx , dx , & 'first-deriv' , 'compact6' ) call backend % alloc_tdsops ( dirps % der1st_sym , nx , dx , & 'first-deriv' , 'compact6' ) call backend % alloc_tdsops ( dirps % der2nd , nx , dx , & 'second-deriv' , 'compact6' ) call backend % alloc_tdsops ( dirps % der2nd_sym , nx , dx , & 'second-deriv' , 'compact6' ) call backend % alloc_tdsops ( dirps % interpl_v2p , nx , dx , & 'interpolate' , 'classic' , from_to = 'v2p' ) call backend % alloc_tdsops ( dirps % interpl_p2v , nx , dx , & 'interpolate' , 'classic' , from_to = 'p2v' ) call backend % alloc_tdsops ( dirps % stagder_v2p , nx , dx , & 'stag-deriv' , 'compact6' , from_to = 'v2p' ) call backend % alloc_tdsops ( dirps % stagder_p2v , nx , dx , & 'stag-deriv' , 'compact6' , from_to = 'p2v' ) end subroutine subroutine transeq ( self , du , dv , dw , u , v , w ) !! Skew-symmetric form of convection-diffusion terms in the !! incompressible Navier-Stokes momemtum equations, excluding !! pressure terms. !! Inputs from velocity grid and outputs to velocity grid. implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w class ( field_t ), pointer :: u_y , v_y , w_y , u_z , v_z , w_z , & du_y , dv_y , dw_y , du_z , dv_z , dw_z ! -1/2(nabla u curl u + u nabla u) + nu nablasq u ! call derivatives in x direction. Based on the run time arguments this ! executes a distributed algorithm or the Thomas algorithm. call self % backend % transeq_x ( du , dv , dw , u , v , w , self % xdirps ) ! request fields from the allocator u_y => self % backend % allocator % get_block () v_y => self % backend % allocator % get_block () w_y => self % backend % allocator % get_block () du_y => self % backend % allocator % get_block () dv_y => self % backend % allocator % get_block () dw_y => self % backend % allocator % get_block () ! reorder data from x orientation to y orientation call self % backend % reorder ( u_y , u , RDR_X2Y ) call self % backend % reorder ( v_y , v , RDR_X2Y ) call self % backend % reorder ( w_y , w , RDR_X2Y ) ! similar to the x direction, obtain derivatives in y. call self % backend % transeq_y ( du_y , dv_y , dw_y , u_y , v_y , w_y , self % ydirps ) ! we don't need the velocities in y orientation any more, so release ! them to open up space. ! It is important that this doesn't actually deallocate any memory, ! it just makes the corresponding memory space available for use. call self % backend % allocator % release_block ( u_y ) call self % backend % allocator % release_block ( v_y ) call self % backend % allocator % release_block ( w_y ) call self % backend % sum_yintox ( du , du_y ) call self % backend % sum_yintox ( dv , dv_y ) call self % backend % sum_yintox ( dw , dw_y ) call self % backend % allocator % release_block ( du_y ) call self % backend % allocator % release_block ( dv_y ) call self % backend % allocator % release_block ( dw_y ) ! just like in y direction, get some fields for the z derivatives. u_z => self % backend % allocator % get_block () v_z => self % backend % allocator % get_block () w_z => self % backend % allocator % get_block () du_z => self % backend % allocator % get_block () dv_z => self % backend % allocator % get_block () dw_z => self % backend % allocator % get_block () ! reorder from x to z call self % backend % reorder ( u_z , u , RDR_X2Z ) call self % backend % reorder ( v_z , v , RDR_X2Z ) call self % backend % reorder ( w_z , w , RDR_X2Z ) ! get the derivatives in z call self % backend % transeq_z ( du_z , dv_z , dw_z , u_z , v_z , w_z , self % zdirps ) ! there is no need to keep velocities in z orientation around, so release call self % backend % allocator % release_block ( u_z ) call self % backend % allocator % release_block ( v_z ) call self % backend % allocator % release_block ( w_z ) ! gather all the contributions into the x result array call self % backend % sum_zintox ( du , du_z ) call self % backend % sum_zintox ( dv , dv_z ) call self % backend % sum_zintox ( dw , dw_z ) ! release all the unnecessary blocks. call self % backend % allocator % release_block ( du_z ) call self % backend % allocator % release_block ( dv_z ) call self % backend % allocator % release_block ( dw_z ) end subroutine transeq subroutine divergence_v2p ( self , div_u , u , v , w ) !! Divergence of a vector field (u, v, w). !! Inputs from velocity grid and outputs to pressure grid. implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: div_u class ( field_t ), intent ( in ) :: u , v , w class ( field_t ), pointer :: du_x , dv_x , dw_x , & u_y , v_y , w_y , du_y , dv_y , dw_y , & u_z , w_z , dw_z du_x => self % backend % allocator % get_block () dv_x => self % backend % allocator % get_block () dw_x => self % backend % allocator % get_block () ! Staggared der for u field in x ! Interpolation for v field in x ! Interpolation for w field in x call self % backend % tds_solve ( du_x , u , self % xdirps , & self % xdirps % stagder_v2p ) call self % backend % tds_solve ( dv_x , v , self % xdirps , & self % xdirps % interpl_v2p ) call self % backend % tds_solve ( dw_x , w , self % xdirps , & self % xdirps % interpl_v2p ) ! request fields from the allocator u_y => self % backend % allocator % get_block () v_y => self % backend % allocator % get_block () w_y => self % backend % allocator % get_block () ! reorder data from x orientation to y orientation call self % backend % reorder ( u_y , du_x , RDR_X2Y ) call self % backend % reorder ( v_y , dv_x , RDR_X2Y ) call self % backend % reorder ( w_y , dw_x , RDR_X2Y ) call self % backend % allocator % release_block ( du_x ) call self % backend % allocator % release_block ( dv_x ) call self % backend % allocator % release_block ( dw_x ) du_y => self % backend % allocator % get_block () dv_y => self % backend % allocator % get_block () dw_y => self % backend % allocator % get_block () ! similar to the x direction, obtain derivatives in y. call self % backend % tds_solve ( du_y , u_y , self % ydirps , & self % ydirps % interpl_v2p ) call self % backend % tds_solve ( dv_y , v_y , self % ydirps , & self % ydirps % stagder_v2p ) call self % backend % tds_solve ( dw_y , w_y , self % ydirps , & self % ydirps % interpl_v2p ) ! we don't need the velocities in y orientation any more, so release ! them to open up space. ! It is important that this doesn't actually deallocate any memory, ! it just makes the corresponding memory space available for use. call self % backend % allocator % release_block ( u_y ) call self % backend % allocator % release_block ( v_y ) call self % backend % allocator % release_block ( w_y ) ! just like in y direction, get some fields for the z derivatives. u_z => self % backend % allocator % get_block () w_z => self % backend % allocator % get_block () ! du_y = dv_y + du_y call self % backend % vecadd ( 1._dp , dv_y , 1._dp , du_y ) ! reorder from y to z call self % backend % reorder ( u_z , du_y , RDR_Y2Z ) call self % backend % reorder ( w_z , dw_y , RDR_Y2Z ) ! release all the unnecessary blocks. call self % backend % allocator % release_block ( du_y ) call self % backend % allocator % release_block ( dv_y ) call self % backend % allocator % release_block ( dw_y ) dw_z => self % backend % allocator % get_block () ! get the derivatives in z call self % backend % tds_solve ( div_u , u_z , self % zdirps , & self % zdirps % interpl_v2p ) call self % backend % tds_solve ( dw_z , w_z , self % zdirps , & self % zdirps % stagder_v2p ) ! div_u = div_u + dw_z call self % backend % vecadd ( 1._dp , dw_z , 1._dp , div_u ) ! div_u array is in z orientation ! there is no need to keep velocities in z orientation around, so release call self % backend % allocator % release_block ( u_z ) call self % backend % allocator % release_block ( w_z ) call self % backend % allocator % release_block ( dw_z ) end subroutine divergence_v2p subroutine gradient_p2v ( self , dpdx , dpdy , dpdz , pressure ) !! Gradient of a scalar field 'pressure'. !! Inputs from pressure grid and outputs to velocity grid. implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: dpdx , dpdy , dpdz class ( field_t ), intent ( in ) :: pressure class ( field_t ), pointer :: p_sxy_z , dpdz_sxy_z , & p_sxy_y , dpdz_sxy_y , & p_sx_y , dpdy_sx_y , dpdz_sx_y , & p_sx_x , dpdy_sx_x , dpdz_sx_x p_sxy_z => self % backend % allocator % get_block () dpdz_sxy_z => self % backend % allocator % get_block () ! Staggared der for pressure field in z ! Interpolation for pressure field in z call self % backend % tds_solve ( p_sxy_z , pressure , self % zdirps , & self % zdirps % interpl_p2v ) call self % backend % tds_solve ( dpdz_sxy_z , pressure , self % zdirps , & self % zdirps % stagder_p2v ) ! request fields from the allocator p_sxy_y => self % backend % allocator % get_block () dpdz_sxy_y => self % backend % allocator % get_block () ! reorder data from z orientation to y orientation call self % backend % reorder ( p_sxy_y , p_sxy_z , RDR_Z2Y ) call self % backend % reorder ( dpdz_sxy_y , dpdz_sxy_z , RDR_Z2Y ) call self % backend % allocator % release_block ( p_sxy_z ) call self % backend % allocator % release_block ( dpdz_sxy_z ) p_sx_y => self % backend % allocator % get_block () dpdy_sx_y => self % backend % allocator % get_block () dpdz_sx_y => self % backend % allocator % get_block () ! similar to the z direction, obtain derivatives in y. call self % backend % tds_solve ( p_sx_y , p_sxy_y , self % ydirps , & self % ydirps % interpl_p2v ) call self % backend % tds_solve ( dpdy_sx_y , p_sxy_y , self % ydirps , & self % ydirps % stagder_p2v ) call self % backend % tds_solve ( dpdz_sx_y , dpdz_sxy_y , self % ydirps , & self % ydirps % interpl_p2v ) ! release memory call self % backend % allocator % release_block ( p_sxy_y ) call self % backend % allocator % release_block ( dpdz_sxy_y ) ! just like in y direction, get some fields for the x derivatives. p_sx_x => self % backend % allocator % get_block () dpdy_sx_x => self % backend % allocator % get_block () dpdz_sx_x => self % backend % allocator % get_block () ! reorder from y to x call self % backend % reorder ( p_sx_x , p_sx_y , RDR_Y2X ) call self % backend % reorder ( dpdy_sx_x , dpdy_sx_y , RDR_Y2X ) call self % backend % reorder ( dpdz_sx_x , dpdz_sx_y , RDR_Y2X ) ! release all the y directional fields. call self % backend % allocator % release_block ( p_sx_y ) call self % backend % allocator % release_block ( dpdy_sx_y ) call self % backend % allocator % release_block ( dpdz_sx_y ) ! get the derivatives in x call self % backend % tds_solve ( dpdx , p_sx_x , self % xdirps , & self % xdirps % stagder_p2v ) call self % backend % tds_solve ( dpdy , dpdy_sx_x , self % xdirps , & self % xdirps % interpl_p2v ) call self % backend % tds_solve ( dpdz , dpdz_sx_x , self % xdirps , & self % xdirps % interpl_p2v ) ! release temporary x fields call self % backend % allocator % release_block ( p_sx_x ) call self % backend % allocator % release_block ( dpdy_sx_x ) call self % backend % allocator % release_block ( dpdz_sx_x ) end subroutine gradient_p2v subroutine curl ( self , o_i_hat , o_j_hat , o_k_hat , u , v , w ) !! Curl of a vector field (u, v, w). !! Inputs from velocity grid and outputs to velocity grid. implicit none class ( solver_t ) :: self !> Vector components of the output vector field Omega class ( field_t ), intent ( inout ) :: o_i_hat , o_j_hat , o_k_hat class ( field_t ), intent ( in ) :: u , v , w class ( field_t ), pointer :: u_y , u_z , v_z , w_y , dwdy_y , dvdz_z , dvdz_x , & dudz_z , dudz_x , dudy_y , dudy_x ! omega_i_hat = dw/dy - dv/dz ! omega_j_hat = du/dz - dw/dx ! omega_k_hat = dv/dx - du/dy ! omega_i_hat ! dw/dy w_y => self % backend % allocator % get_block () dwdy_y => self % backend % allocator % get_block () call self % backend % reorder ( w_y , w , RDR_X2Y ) call self % backend % tds_solve ( dwdy_y , w_y , self % ydirps , self % ydirps % der1st ) call self % backend % reorder ( o_i_hat , dwdy_y , RDR_Y2X ) call self % backend % allocator % release_block ( w_y ) call self % backend % allocator % release_block ( dwdy_y ) ! dv/dz v_z => self % backend % allocator % get_block () dvdz_z => self % backend % allocator % get_block () call self % backend % reorder ( v_z , v , RDR_X2Z ) call self % backend % tds_solve ( dvdz_z , v_z , self % zdirps , self % zdirps % der1st ) dvdz_x => self % backend % allocator % get_block () call self % backend % reorder ( dvdz_x , dvdz_z , RDR_Z2X ) call self % backend % allocator % release_block ( v_z ) call self % backend % allocator % release_block ( dvdz_z ) ! omega_i_hat = dw/dy - dv/dz call self % backend % vecadd ( - 1._dp , dvdz_x , 1._dp , o_i_hat ) call self % backend % allocator % release_block ( dvdz_x ) ! omega_j_hat ! du/dz u_z => self % backend % allocator % get_block () dudz_z => self % backend % allocator % get_block () call self % backend % reorder ( u_z , u , RDR_X2Z ) call self % backend % tds_solve ( dudz_z , u_z , self % zdirps , self % zdirps % der1st ) dudz_x => self % backend % allocator % get_block () call self % backend % reorder ( dudz_x , dudz_z , RDR_Z2X ) call self % backend % allocator % release_block ( u_z ) call self % backend % allocator % release_block ( dudz_z ) ! dw/dx call self % backend % tds_solve ( o_j_hat , w , self % xdirps , self % xdirps % der1st ) ! omega_j_hat = du/dz - dw/dx call self % backend % vecadd ( 1._dp , dudz_x , - 1._dp , o_j_hat ) call self % backend % allocator % release_block ( dudz_x ) ! omega_k_hat ! dv/dx call self % backend % tds_solve ( o_k_hat , v , self % xdirps , self % xdirps % der1st ) ! du/dy u_y => self % backend % allocator % get_block () dudy_y => self % backend % allocator % get_block () call self % backend % reorder ( u_y , u , RDR_X2Y ) call self % backend % tds_solve ( dudy_y , u_y , self % ydirps , self % ydirps % der1st ) dudy_x => self % backend % allocator % get_block () call self % backend % reorder ( dudy_x , dudy_y , RDR_Y2X ) call self % backend % allocator % release_block ( u_y ) call self % backend % allocator % release_block ( dudy_y ) ! omega_k_hat = dv/dx - du/dy call self % backend % vecadd ( - 1._dp , dudy_x , 1._dp , o_k_hat ) call self % backend % allocator % release_block ( dudy_x ) end subroutine curl subroutine poisson_fft ( self , pressure , div_u ) implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: pressure class ( field_t ), intent ( in ) :: div_u ! call forward FFT ! output array in spectral space is stored at poisson_fft class call self % backend % poisson_fft % fft_forward ( div_u ) ! postprocess call self % backend % poisson_fft % fft_postprocess ! call backward FFT call self % backend % poisson_fft % fft_backward ( pressure ) end subroutine poisson_fft subroutine poisson_cg ( self , pressure , div_u ) implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: pressure class ( field_t ), intent ( in ) :: div_u end subroutine poisson_cg subroutine output ( self , t , u_out ) implicit none class ( solver_t ), intent ( in ) :: self real ( dp ), intent ( in ) :: t real ( dp ), dimension (:, :, :), intent ( inout ) :: u_out class ( field_t ), pointer :: du , dv , dw integer :: ngrid ngrid = self % xdirps % n * self % ydirps % n * self % zdirps % n print * , 'time = ' , t du => self % backend % allocator % get_block () dv => self % backend % allocator % get_block () dw => self % backend % allocator % get_block () call self % curl ( du , dv , dw , self % u , self % v , self % w ) print * , 'enstrophy:' , 0.5_dp * ( & self % backend % scalar_product ( du , du ) & + self % backend % scalar_product ( dv , dv ) & + self % backend % scalar_product ( dw , dw ) & ) / ngrid call self % backend % allocator % release_block ( du ) call self % backend % allocator % release_block ( dv ) call self % backend % allocator % release_block ( dw ) call self % divergence_v2p ( du , self % u , self % v , self % w ) call self % backend % get_field ( u_out , du ) print * , 'div u max mean:' , maxval ( abs ( u_out )), sum ( abs ( u_out )) / ngrid end subroutine output subroutine run ( self , u_out , v_out , w_out ) implicit none class ( solver_t ), intent ( in ) :: self real ( dp ), dimension (:, :, :), intent ( inout ) :: u_out , v_out , w_out class ( field_t ), pointer :: du , dv , dw , div_u , pressure , dpdx , dpdy , dpdz real ( dp ) :: t integer :: i print * , 'initial conditions' t = 0._dp call self % output ( t , u_out ) print * , 'start run' do i = 1 , self % n_iters du => self % backend % allocator % get_block () dv => self % backend % allocator % get_block () dw => self % backend % allocator % get_block () call self % transeq ( du , dv , dw , self % u , self % v , self % w ) ! time integration call self % time_integrator % step ( self % u , self % v , self % w , & du , dv , dw , self % dt ) call self % backend % allocator % release_block ( du ) call self % backend % allocator % release_block ( dv ) call self % backend % allocator % release_block ( dw ) ! pressure div_u => self % backend % allocator % get_block () call self % divergence_v2p ( div_u , self % u , self % v , self % w ) pressure => self % backend % allocator % get_block () call self % poisson ( pressure , div_u ) call self % backend % allocator % release_block ( div_u ) dpdx => self % backend % allocator % get_block () dpdy => self % backend % allocator % get_block () dpdz => self % backend % allocator % get_block () call self % gradient_p2v ( dpdx , dpdy , dpdz , pressure ) call self % backend % allocator % release_block ( pressure ) ! velocity correction call self % backend % vecadd ( - 1._dp , dpdx , 1._dp , self % u ) call self % backend % vecadd ( - 1._dp , dpdy , 1._dp , self % v ) call self % backend % vecadd ( - 1._dp , dpdz , 1._dp , self % w ) call self % backend % allocator % release_block ( dpdx ) call self % backend % allocator % release_block ( dpdy ) call self % backend % allocator % release_block ( dpdz ) if ( mod ( i , self % n_output ) == 0 ) then t = i * self % dt call self % output ( t , u_out ) end if end do print * , 'run end' call self % backend % get_field ( u_out , self % u ) call self % backend % get_field ( v_out , self % v ) call self % backend % get_field ( w_out , self % w ) end subroutine run end module m_solver","tags":"","loc":"sourcefile/solver.f90.html"},{"title":"tdsops.f90 – x3d2","text":"Source Code module m_tdsops use iso_fortran_env , only : stderr => error_unit use m_common , only : dp , pi implicit none type :: tdsops_t !! Tridiagonal Solver Operators class. !! !! Operator arrays are preprocessed in this class based on the arguments !! provided. dist_fw and dist_bw are used in the first phase of the !! distributed tridiagonal solver algorithm. dist_sa and dist_sc are used !! in the final substitution phase. See the kernels_dist.f90 files in the !! relevant backend folders. !! coeff arrays define the specific rules of building the RHS !! corresponding to the tridiagonal system to be solved, and used only in !! the first phase of the distributed algorithm when building the RHS. !! If a boundary condition is defined then coeffs_s and coeffs_e differ !! from coeffs array and define the RHS rule for the first and last 4 !! entries in the tridiagonal system (n_halo = 4). !! !! This class does not know about the current rank or its relative !! location among other ranks. All the operator arrays here are used when !! executing a distributed tridiagonal solver phase one or two. real ( dp ), allocatable , dimension (:) :: dist_fw , dist_bw , & !! fw/bw phase dist_sa , dist_sc , & !! back subs. dist_af !! the auxiliary factors real ( dp ), allocatable :: coeffs (:), coeffs_s (:, :), coeffs_e (:, :) real ( dp ) :: alpha , a , b , c = 0._dp , d = 0._dp integer :: n , n_halo contains procedure :: deriv_1st , deriv_2nd , interpl_mid , stagder_1st , preprocess end type tdsops_t interface tdsops_t module procedure tdsops_init end interface tdsops_t type :: dirps_t !! Directional tridiagonal solver container. !! !! This class contains the preprocessed tridiagonal solvers for operating !! in each coordinate direction. class ( tdsops_t ), allocatable :: der1st , der1st_sym , & der2nd , der2nd_sym , & stagder_v2p , stagder_p2v , & interpl_v2p , interpl_p2v integer :: nrank , nproc , pnext , pprev , n , n_blocks real ( dp ) :: L , d end type dirps_t contains function tdsops_init ( n , delta , operation , scheme , n_halo , from_to , & bc_start , bc_end , sym , c_nu , nu0_nu ) result ( tdsops ) !! Constructor function for the tdsops_t class. !! !! 'n', 'delta', 'operation', and 'scheme' are necessary arguments. !! Number of points 'n', distance between two points 'delta', the !! 'operation' the tridiagonal system defines, and the 'scheme' that !! specifies the exact scheme we choose to apply for the operation. !! The remaining arguments are optional. !! 'from_to' is necessary for interpolation and staggared derivative, and !! it can be 'v2p' or 'p2v'. !! If the specific region the instance is operating is not a boundary !! region, then 'bc_start' and 'bc_end' are either 'null' or not defined. !! 'sym' is relevant when the boundary condition is free-slip. If sym is !! .true. then it means the field we operate on is assumed to be an even !! function (symmetric) accross the boundary. If it is .false. it means !! that the field is assumed to be an odd function (anti-symmetric). !! 'c_nu', 'nu0_nu' are relevant when operation is second order !! derivative and scheme is compact6-hyperviscous. implicit none type ( tdsops_t ) :: tdsops !! return value of the function integer , intent ( in ) :: n real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: operation , scheme integer , optional , intent ( in ) :: n_halo !! Number of halo cells character ( * ), optional , intent ( in ) :: from_to !! 'v2p' or 'p2v' character ( * ), optional , intent ( in ) :: bc_start , bc_end !! Boundary Cond. logical , optional , intent ( in ) :: sym !! (==npaire), only for Neumann BCs real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu !! params for hypervisc. integer :: n_stencil tdsops % n = n if ( present ( n_halo )) then tdsops % n_halo = n_halo if ( n_halo /= 4 ) then write ( stderr , '(\"Warning: n_halo is set to \", i2, \"be careful! & &The default is 4 and there are quite a few & &places where things are hardcoded assuming & &n_halo is 4.\")' ) n_halo end if else tdsops % n_halo = 4 end if n_stencil = 2 * tdsops % n_halo + 1 allocate ( tdsops % dist_fw ( n ), tdsops % dist_bw ( n )) allocate ( tdsops % dist_sa ( n ), tdsops % dist_sc ( n )) allocate ( tdsops % dist_af ( n )) allocate ( tdsops % coeffs ( n_stencil )) allocate ( tdsops % coeffs_s ( n_stencil , tdsops % n_halo )) allocate ( tdsops % coeffs_e ( n_stencil , tdsops % n_halo )) if ( operation == 'first-deriv' ) then call tdsops % deriv_1st ( delta , scheme , bc_start , bc_end , sym ) else if ( operation == 'second-deriv' ) then call tdsops % deriv_2nd ( delta , scheme , bc_start , bc_end , sym , & c_nu , nu0_nu ) else if ( operation == 'interpolate' ) then call tdsops % interpl_mid ( scheme , from_to , bc_start , bc_end , sym ) else if ( operation == 'stag-deriv' ) then call tdsops % stagder_1st ( delta , scheme , from_to , bc_start , bc_end , sym ) else error stop 'operation is not defined' end if end function tdsops_init subroutine deriv_1st ( self , delta , scheme , bc_start , bc_end , sym ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: scheme character ( * ), optional , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , afi , bfi integer :: i , n , n_halo logical :: symmetry if ( self % n_halo < 2 ) error stop 'First derivative require n_halo >= 2' if ( present ( sym )) then symmetry = sym else symmetry = . false . end if ! alpha is alfa select case ( scheme ) case ( 'compact6' ) alpha = 1._dp / 3._dp afi = 7._dp / 9._dp / delta bfi = 1._dp / 3 6._dp / delta case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = afi ; self % b = bfi self % coeffs (:) = [ 0._dp , 0._dp , - bfi , - afi , & 0._dp , & afi , bfi , 0._dp , 0._dp ] do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % n n_halo = self % n_halo allocate ( dist_b ( n )) dist_b (:) = 1._dp select case ( bc_start ) case ( 'neumann' ) if ( symmetry ) then ! sym == .true.; d(uu)/dx, dv/dx, dw/dx !                d(vv)/dy, du/dy, dw/dy !                d(ww)/dz, du/dz, dv/dz self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 0._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - afi , & - bfi , & afi , bfi , 0._dp , 0._dp ] else ! sym == .false.; d(uv)/dx, d(uw)/dx, du/dx !                 d(vu)/dy, d(vw)/dy, dv/dy !                 d(wu)/dz, d(wv)/dz, dw/dz self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 2 * alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 2 * afi , 2 * bfi , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - afi , & bfi , & afi , bfi , 0._dp , 0._dp ] end if case ( 'dirichlet' ) ! first line self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 2._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & - 2.5_dp , & 2._dp , 0.5_dp , 0._dp , 0._dp ] self % coeffs_s (:, 1 ) = self % coeffs_s (:, 1 ) / delta ! second line self % dist_sa ( 2 ) = 0.25_dp self % dist_sc ( 2 ) = 0.25_dp self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - 0.75_dp , & 0._dp , & 0.75_dp , 0._dp , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = self % coeffs_s (:, 2 ) / delta end select select case ( bc_end ) case ( 'neumann' ) if ( symmetry ) then ! sym == .true.; d(uu)/dx, dv/dx, dw/dx !                d(vv)/dy, du/dy, dw/dy !                d(ww)/dz, du/dz, dv/dz self % dist_sa ( n ) = 0._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , - bfi , - afi , & bfi , & afi , 0._dp , 0._dp , 0._dp ] else ! sym == .false.; d(uv)/dx, d(uw)/dx, du/dx !                 d(vu)/dy, d(vw)/dy, dv/dy !                 d(wu)/dz, d(wv)/dz, dw/dz self % dist_sa ( n ) = 2 * alpha self % dist_sc ( n ) = 0._dp self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , - 2 * bfi , - 2 * afi , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , - bfi , - afi , & - bfi , & afi , 0._dp , 0._dp , 0._dp ] end if case ( 'dirichlet' ) ! last line self % dist_sa ( n ) = 2._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , - 0.5_dp , - 2._dp , & 2.5_dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo ) = self % coeffs_e (:, n_halo ) / delta ! second last line self % dist_sa ( n - 1 ) = 0.25_dp self % dist_sc ( n - 1 ) = 0.25_dp self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , 0._dp , - 0.75_dp , & 0._dp , & 0.75_dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = self % coeffs_e (:, n_halo - 1 ) / delta end select call self % preprocess ( dist_b ) end subroutine deriv_1st subroutine deriv_2nd ( self , delta , scheme , bc_start , bc_end , sym , & c_nu , nu0_nu ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: scheme character ( * ), optional , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , asi , bsi , csi , dsi real ( dp ) :: dpis3 , xnpi2 , xmpi2 , den , d2 , temp1 , temp2 integer :: i , n , n_halo logical :: symmetry if ( self % n_halo < 4 ) error stop 'Second derivative require n_halo >= 4' if ( present ( sym )) then symmetry = sym else symmetry = . false . end if d2 = delta * delta ! alpha is alsa select case ( scheme ) case ( 'compact6' ) alpha = 2._dp / 1 1._dp asi = 1 2._dp / 1 1._dp / d2 bsi = 3._dp / 4 4._dp / d2 csi = 0._dp dsi = 0._dp case ( 'compact6-hyperviscous' ) if ( present ( c_nu ) . and . present ( nu0_nu )) then dpis3 = 2._dp * pi / 3._dp xnpi2 = pi * pi * ( 1._dp + nu0_nu ) xmpi2 = dpis3 * dpis3 * ( 1._dp + c_nu * nu0_nu ) den = 40 5._dp * xnpi2 - 64 0._dp * xmpi2 + 14 4._dp alpha = 0.5_dp - ( 32 0._dp * xmpi2 - 129 6._dp ) / den asi = - ( 432 9._dp * xnpi2 / 8._dp - 3 2._dp * xmpi2 & - 14 0._dp * xnpi2 * xmpi2 + 28 6._dp ) / den / d2 bsi = ( 211 5._dp * xnpi2 - 179 2._dp * xmpi2 & - 28 0._dp * xnpi2 * xmpi2 + 132 8._dp ) / den / ( 4._dp * d2 ) csi = - ( 769 5._dp * xnpi2 / 8._dp + 28 8._dp * xmpi2 & - 18 0._dp * xnpi2 * xmpi2 - 257 4._dp ) / den / ( 9._dp * d2 ) dsi = ( 19 8._dp * xnpi2 + 12 8._dp * xmpi2 & - 4 0._dp * xnpi2 * xmpi2 - 73 6._dp ) / den / ( 1 6._dp * d2 ) else error stop 'compact6-hyperviscous requires c_nu and nu0_nu' end if case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = asi ; self % b = bsi ; self % c = csi ; self % d = dsi self % coeffs (:) = [ dsi , csi , bsi , asi , & - 2._dp * ( asi + bsi + csi + dsi ), & asi , bsi , csi , dsi ] do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % n n_halo = self % n_halo allocate ( dist_b ( n )) dist_b (:) = 1._dp select case ( bc_start ) case ( 'neumann' ) if ( symmetry ) then ! sym == .true.; d2v/dx2, d2w/dx2 !                d2u/dy2, d2w/dy2 !                d2u/dz2, d2v/dz2 self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 2 * alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & 2 * asi , 2 * bsi , 2 * csi , 2 * dsi ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , asi , & - 2 * asi - bsi - 2 * csi - 2 * dsi , & asi + csi , bsi + dsi , csi , dsi ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , bsi , asi + csi , & - 2 * asi - 2 * bsi - 2 * csi - dsi , & asi , bsi , csi , dsi ] self % coeffs_s (:, 4 ) = [ 0._dp , csi , bsi + dsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi , csi , dsi ] else ! sym == .false.; d2u/dx2 !                 d2v/dy2 !                 d2w/dz2 self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 0._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , asi , & - 2 * asi - 3 * bsi - 2 * csi - 2 * dsi , & asi - csi , bsi - dsi , csi , dsi ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , bsi , asi - csi , & - 2 * asi - 2 * bsi - 2 * csi - 3 * dsi , & asi , bsi , csi , dsi ] self % coeffs_s (:, 4 ) = [ 0._dp , - csi , bsi - dsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi , csi , dsi ] end if case ( 'dirichlet' ) ! first line self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 1 1._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 1 3._dp / d2 , & - 2 7._dp / d2 , 1 5._dp / d2 , - 1._dp / d2 , 0._dp ] ! second line self % dist_sa ( 2 ) = 0.1_dp self % dist_sc ( 2 ) = 0.1_dp self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , 1.2_dp / d2 , & - 2.4_dp / d2 , & 1.2_dp / d2 , 0._dp , 0._dp , 0._dp ] ! third line self % dist_sa ( 3 ) = 2._dp / 1 1._dp self % dist_sc ( 3 ) = 2._dp / 1 1._dp temp1 = 3._dp / 4 4._dp / d2 ; temp2 = 1 2._dp / 1 1._dp / d2 self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , temp1 , temp2 , & - 2._dp * ( temp1 + temp2 ), & temp2 , temp1 , 0._dp , 0._dp ] ! fourth line is same as third self % dist_sa ( 4 ) = 2._dp / 1 1._dp self % dist_sc ( 4 ) = 2._dp / 1 1._dp self % coeffs_s (:, 4 ) = self % coeffs_s (:, 3 ) end select select case ( bc_end ) case ( 'neumann' ) if ( symmetry ) then ! sym == .true.; d2v/dx2, d2w/dx2 !                d2u/dy2, d2w/dy2 !                d2u/dz2, d2v/dz2 self % dist_sa ( n ) = 2 * alpha self % dist_sc ( n ) = 0._dp self % coeffs_e (:, 4 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 3 ) = [ dsi , csi , bsi + dsi , asi + csi , & - 2 * asi - bsi - 2 * csi - 2 * dsi , & asi , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - dsi , & asi + csi , bsi , 0._dp , 0._dp ] self % coeffs_e (:, 1 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi + dsi , csi , 0._dp ] else ! sym == .false.; d2u/dx2 !                 d2v/dy2 !                 d2w/dz2 self % dist_sa ( n ) = 0._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, 4 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 3 ) = [ dsi , csi , bsi - dsi , asi - csi , & - 2 * asi - 3 * bsi - 2 * csi - 2 * dsi , & asi , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 3 * dsi , & asi - csi , bsi , 0._dp , 0._dp ] self % coeffs_e (:, 1 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi - dsi , - csi , 0._dp ] end if case ( 'dirichlet' ) ! last line self % dist_sa ( n ) = 1 1._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, 4 ) = [ 0._dp , - 1._dp / d2 , 1 5._dp / d2 , - 2 7._dp / d2 , & 1 3._dp / d2 , & 0._dp , 0._dp , 0._dp , 0._dp ] ! second last line self % dist_sa ( n - 1 ) = 0.1_dp self % dist_sc ( n - 1 ) = 0.1_dp self % coeffs_e (:, 3 ) = [ 0._dp , 0._dp , 0._dp , 1.2_dp / d2 , & - 2.4_dp / d2 , & 1.2_dp / d2 , 0._dp , 0._dp , 0._dp ] ! third last line self % dist_sa ( n - 2 ) = 2._dp / 1 1._dp self % dist_sc ( n - 2 ) = 2._dp / 1 1._dp temp1 = 3._dp / 4 4._dp / d2 ; temp2 = 1 2._dp / 1 1._dp / d2 self % coeffs_e (:, 2 ) = [ 0._dp , 0._dp , temp1 , temp2 , & - 2._dp * ( temp1 + temp2 ), & temp2 , temp1 , 0._dp , 0._dp ] ! fourth last line is same as third last self % dist_sa ( n - 3 ) = 2._dp / 1 1._dp self % dist_sc ( n - 3 ) = 2._dp / 1 1._dp self % coeffs_e (:, 1 ) = self % coeffs_e (:, 2 ) end select call self % preprocess ( dist_b ) end subroutine deriv_2nd subroutine interpl_mid ( self , scheme , from_to , bc_start , bc_end , sym ) implicit none class ( tdsops_t ), intent ( inout ) :: self character ( * ), intent ( in ) :: scheme , from_to character ( * ), optional , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , aici , bici , cici , dici integer :: i , n , n_halo if ( self % n_halo < 4 ) error stop 'Interpolation require n_halo >= 4' ! alpha is ailcai select case ( scheme ) case ( 'classic' ) alpha = 0.3_dp aici = 0.75_dp bici = 0.05_dp cici = 0._dp dici = 0._dp case ( 'optimised' ) alpha = 0.461658_dp dici = 0.00146508_dp aici = ( 7 5._dp + 7 0._dp * alpha - 64 0._dp * dici ) / 12 8._dp bici = ( - 2 5._dp + 12 6._dp * alpha + 230 4._dp * dici ) / 25 6._dp cici = ( 3._dp - 1 0._dp * alpha - 128 0._dp * dici ) / 25 6._dp case ( 'aggressive' ) alpha = 0.49_dp aici = ( 7 5._dp + 7 0._dp * alpha ) / 12 8._dp bici = ( - 2 5._dp + 12 6._dp * alpha ) / 25 6._dp cici = ( 3._dp - 1 0._dp * alpha ) / 25 6._dp dici = 0._dp case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = aici ; self % b = bici ; self % c = cici ; self % d = dici select case ( from_to ) case ( 'v2p' ) self % coeffs (:) = [ 0._dp , dici , cici , bici , & aici , & aici , bici , cici , dici ] case ( 'p2v' ) self % coeffs (:) = [ dici , cici , bici , aici , & aici , & bici , cici , dici , 0._dp ] end select do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % n n_halo = self % n_halo allocate ( dist_b ( n )) dist_b (:) = 1._dp if (( bc_start == 'dirichlet' ) . or . ( bc_start == 'neumann' )) then self % dist_sa ( 1 ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .true. dist_b ( 1 ) = 1._dp + alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & aici , & aici + bici , bici + cici , cici + dici , dici ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , bici , & aici + cici , & aici + dici , bici , cici , dici ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , cici , bici + dici , & aici , & aici , bici , cici , dici ] case ( 'p2v' ) ! sym is always .true. self % dist_sc ( 1 ) = 2 * alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 2 * aici , & 2 * bici , 2 * cici , 2 * dici , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , aici + bici , & aici + cici , & bici + dici , cici , dici , 0._dp ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , bici + cici , aici + dici , & aici , & bici , cici , dici , 0._dp ] self % coeffs_s (:, 4 ) = [ 0._dp , cici + dici , bici , aici , & aici , & bici , cici , dici , 0._dp ] end select end if if (( bc_end == 'dirichlet' ) . or . ( bc_end == 'neumann' )) then self % dist_sc ( n ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .true. dist_b ( n ) = 1._dp + alpha self % coeffs_e (:, 4 ) = [ 0._dp , dici , cici + dici , bici + cici , & aici + bici , & aici , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 3 ) = [ 0._dp , dici , cici , bici , & aici + dici , & aici + cici , bici , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ 0._dp , dici , cici , bici , & aici , & aici , bici + dici , cici , 0._dp ] case ( 'p2v' ) ! sym is always .true. self % dist_sa ( n ) = 2 * alpha self % coeffs_e (:, 4 ) = [ 2 * dici , 2 * cici , 2 * bici , 2 * aici , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 3 ) = [ dici , cici , bici + dici , aici + cici , & aici + bici , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ dici , cici , bici , aici , & aici + dici , & bici + cici , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 1 ) = [ dici , cici , bici , aici , & aici , & bici , cici + dici , 0._dp , 0._dp ] end select end if call self % preprocess ( dist_b ) end subroutine interpl_mid subroutine stagder_1st ( self , delta , scheme , from_to , bc_start , bc_end , sym ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: scheme , from_to character ( * ), optional , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , aci , bci integer :: i , n , n_halo if ( self % n_halo < 2 ) error stop 'Staggared deriv require n_halo >= 2' ! alpha is alcai select case ( scheme ) case ( 'compact6' ) alpha = 9._dp / 6 2._dp aci = 6 3._dp / 6 2._dp / delta bci = 1 7._dp / 6 2._dp / 3._dp / delta case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = aci ; self % b = bci select case ( from_to ) case ( 'v2p' ) self % coeffs (:) = [ 0._dp , 0._dp , 0._dp , - bci , & - aci , & aci , bci , 0._dp , 0._dp ] case ( 'p2v' ) self % coeffs (:) = [ 0._dp , 0._dp , - bci , - aci , & aci , & bci , 0._dp , 0._dp , 0._dp ] end select do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % n n_halo = self % n_halo allocate ( dist_b ( n )) dist_b (:) = 1._dp if (( bc_start == 'dirichlet' ) . or . ( bc_start == 'neumann' )) then self % dist_sa ( 1 ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .false. dist_b ( 1 ) = 1._dp + alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & - aci - 2 * bci , & aci + bci , bci , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - bci , & - aci , & aci , bci , 0._dp , 0._dp ] case ( 'p2v' ) ! sym is always .true. self % dist_sc ( 1 ) = 0._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - aci - bci , & aci , & bci , 0._dp , 0._dp , 0._dp ] end select end if if (( bc_end == 'dirichlet' ) . or . ( bc_end == 'neumann' )) then self % dist_sc ( n ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .false. dist_b ( n ) = 1._dp + alpha self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , 0._dp , - bci , & - aci - bci , & aci + 2 * bci , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , 0._dp , - bci , & - aci , & aci , bci , 0._dp , 0._dp ] case ( 'p2v' ) ! sym is always .true. self % dist_sa ( n ) = 0._dp self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , - bci , - aci , & aci + bci , & 0._dp , 0._dp , 0._dp , 0._dp ] end select end if call self % preprocess ( dist_b ) end subroutine stagder_1st subroutine preprocess ( self , dist_b ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), dimension (:), intent ( in ) :: dist_b integer :: i ! Ref DOI: 10.1109/MCSE.2021.3130544 ! Algorithm 3 in page 4 ! First two lines first do i = 1 , 2 self % dist_sa ( i ) = self % dist_sa ( i ) / dist_b ( i ) self % dist_sc ( i ) = self % dist_sc ( i ) / dist_b ( i ) self % dist_bw ( i ) = self % dist_sc ( i ) self % dist_af ( i ) = 1._dp / dist_b ( i ) end do ! Then the remaining in the forward pass do i = 3 , self % n ! Algorithm 3 in ref obtains 'r' coeffs on the fly in line 7. ! As we have to solve many RHSs with the same tridiagonal system, ! it is better to do a preprocessing first. ! So lets store 'r' coeff in dist_fw array. self % dist_fw ( i ) = 1._dp / ( dist_b ( i ) & - self % dist_sa ( i ) * self % dist_sc ( i - 1 )) ! dist_af is 'a_i' in line 7 of Algorithm 3 in ref. self % dist_af ( i ) = self % dist_sa ( i ) ! We store a_i&#94;* and c_i&#94;* in dist_sa and dist_sc because ! we need them later in the substitution phase. self % dist_sa ( i ) = - self % dist_fw ( i ) * self % dist_sa ( i ) & * self % dist_sa ( i - 1 ) self % dist_sc ( i ) = self % dist_fw ( i ) * self % dist_sc ( i ) end do ! backward pass starting in line 12 of Algorithm 3. do i = self % n - 2 , 2 , - 1 self % dist_sa ( i ) = self % dist_sa ( i ) & - self % dist_sc ( i ) * self % dist_sa ( i + 1 ) self % dist_bw ( i ) = self % dist_sc ( i ) self % dist_sc ( i ) = - self % dist_sc ( i ) * self % dist_sc ( i + 1 ) end do ! Line 17 and 18 are tricky ! First we have a new 'r', we need it. ! And for 'r' we need c_0&#94;*... ! Now examine closely, c_0&#94;* is set in line 4 and never overwritten! ! So we can use dist_sc(1) as is in place of c_0&#94;*. ! We need to store this new 'r' somewhere ... ! dist_fw(1) is never used, so store this extra 'r' factor here instead self % dist_fw ( 1 ) = 1._dp / ( 1._dp - self % dist_sc ( 1 ) * self % dist_sa ( 2 )) ! Finally Line 19 and 20 in Algorithm 3 in ref. self % dist_sa ( 1 ) = self % dist_fw ( 1 ) * self % dist_sa ( 1 ) self % dist_sc ( 1 ) = - self % dist_fw ( 1 ) * self % dist_sc ( 1 ) * self % dist_sc ( 2 ) end subroutine preprocess end module m_tdsops","tags":"","loc":"sourcefile/tdsops.f90~2.html"},{"title":"time_integrator.f90 – x3d2","text":"Source Code module m_time_integrator use m_allocator , only : allocator_t , field_t , flist_t use m_base_backend , only : base_backend_t use m_common , only : dp implicit none type :: time_intg_t integer :: istep , nsteps , nsubsteps , order , nvars , nolds type ( flist_t ), allocatable :: olds (:,:) class ( base_backend_t ), pointer :: backend class ( allocator_t ), pointer :: allocator contains procedure :: step end type time_intg_t interface time_intg_t module procedure constructor end interface time_intg_t contains function constructor ( backend , allocator , nvars ) implicit none type ( time_intg_t ) :: constructor class ( base_backend_t ), pointer :: backend class ( allocator_t ), pointer :: allocator integer , intent ( in ), optional :: nvars integer :: i , j constructor % backend => backend constructor % allocator => allocator if ( present ( nvars )) then constructor % nvars = nvars else constructor % nvars = 3 end if constructor % nolds = 0 allocate ( constructor % olds ( constructor % nvars , constructor % nolds )) ! Request all the storage for old timesteps do i = 1 , constructor % nvars do j = 1 , constructor % nolds constructor % olds ( i , j )% ptr => allocator % get_block () end do end do end function constructor subroutine step ( self , u , v , w , du , dv , dw , dt ) implicit none class ( time_intg_t ), intent ( in ) :: self class ( field_t ), intent ( inout ) :: u , v , w class ( field_t ), intent ( in ) :: du , dv , dw real ( dp ), intent ( in ) :: dt call self % backend % vecadd ( dt , du , 1._dp , u ) call self % backend % vecadd ( dt , dv , 1._dp , v ) call self % backend % vecadd ( dt , dw , 1._dp , w ) end subroutine step subroutine adams_bashford_1st ( vels , olds , coeffs ) type ( flist_t ) :: vels (:), olds (:) real :: coeffs (:) !call vec_add(vels, olds, coeffs) end subroutine adams_bashford_1st end module m_time_integrator","tags":"","loc":"sourcefile/time_integrator.f90.html"},{"title":"sendrecv.f90 – x3d2","text":"Source Code module m_omp_sendrecv use mpi use m_common , only : dp implicit none contains subroutine sendrecv_fields ( f_recv_s , f_recv_e , f_send_s , f_send_e , & n_data , nproc , prev , next ) implicit none real ( dp ), dimension (:, :, :), intent ( out ) :: f_recv_s , f_recv_e real ( dp ), dimension (:, :, :), intent ( in ) :: f_send_s , f_send_e integer , intent ( in ) :: n_data , nproc , prev , next integer :: req ( 4 ), err ( 4 ), ierr , tag = 1234 if ( nproc == 1 ) then f_recv_s = f_send_e f_recv_e = f_send_s else call MPI_Isend ( f_send_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 1 ), err ( 1 )) call MPI_Irecv ( f_recv_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 2 ), err ( 2 )) call MPI_Isend ( f_send_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 3 ), err ( 3 )) call MPI_Irecv ( f_recv_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 4 ), err ( 4 )) call MPI_Waitall ( 4 , req , MPI_STATUSES_IGNORE , ierr ) end if end subroutine sendrecv_fields end module m_omp_sendrecv","tags":"","loc":"sourcefile/sendrecv.f90~2.html"},{"title":"backend.f90 – x3d2","text":"Source Code module m_cuda_backend use iso_fortran_env , only : stderr => error_unit use cudafor use mpi use m_allocator , only : allocator_t , field_t use m_base_backend , only : base_backend_t use m_common , only : dp , globs_t , & RDR_X2Y , RDR_X2Z , RDR_Y2X , RDR_Y2Z , RDR_Z2X , RDR_Z2Y use m_poisson_fft , only : poisson_fft_t use m_tdsops , only : dirps_t , tdsops_t use m_cuda_allocator , only : cuda_allocator_t , cuda_field_t use m_cuda_common , only : SZ use m_cuda_exec_dist , only : exec_dist_transeq_3fused , exec_dist_tds_compact use m_cuda_poisson_fft , only : cuda_poisson_fft_t use m_cuda_sendrecv , only : sendrecv_fields , sendrecv_3fields use m_cuda_tdsops , only : cuda_tdsops_t use m_cuda_kernels_dist , only : transeq_3fused_dist , transeq_3fused_subs use m_cuda_kernels_reorder , only : & reorder_x2y , reorder_x2z , reorder_y2x , reorder_y2z , reorder_z2x , & reorder_z2y , sum_yintox , sum_zintox , scalar_product , axpby , buffer_copy implicit none type , extends ( base_backend_t ) :: cuda_backend_t !character(len=*), parameter :: name = 'cuda' integer :: MPI_FP_PREC = dp real ( dp ), device , allocatable , dimension (:, :, :) :: & u_recv_s_dev , u_recv_e_dev , u_send_s_dev , u_send_e_dev , & v_recv_s_dev , v_recv_e_dev , v_send_s_dev , v_send_e_dev , & w_recv_s_dev , w_recv_e_dev , w_send_s_dev , w_send_e_dev , & du_send_s_dev , du_send_e_dev , du_recv_s_dev , du_recv_e_dev , & dud_send_s_dev , dud_send_e_dev , dud_recv_s_dev , dud_recv_e_dev , & d2u_send_s_dev , d2u_send_e_dev , d2u_recv_s_dev , d2u_recv_e_dev type ( dim3 ) :: xblocks , xthreads , yblocks , ythreads , zblocks , zthreads contains procedure :: alloc_tdsops => alloc_cuda_tdsops procedure :: transeq_x => transeq_x_cuda procedure :: transeq_y => transeq_y_cuda procedure :: transeq_z => transeq_z_cuda procedure :: tds_solve => tds_solve_cuda procedure :: reorder => reorder_cuda procedure :: sum_yintox => sum_yintox_cuda procedure :: sum_zintox => sum_zintox_cuda procedure :: vecadd => vecadd_cuda procedure :: scalar_product => scalar_product_cuda procedure :: set_field => set_field_cuda procedure :: get_field => get_field_cuda procedure :: init_poisson_fft => init_cuda_poisson_fft procedure :: transeq_cuda_dist procedure :: transeq_cuda_thom procedure :: tds_solve_dist end type cuda_backend_t interface cuda_backend_t module procedure init end interface cuda_backend_t contains function init ( globs , allocator ) result ( backend ) implicit none class ( globs_t ) :: globs class ( allocator_t ), target , intent ( inout ) :: allocator type ( cuda_backend_t ) :: backend type ( cuda_poisson_fft_t ) :: cuda_poisson_fft integer :: n_halo , n_block select type ( allocator ) type is ( cuda_allocator_t ) ! class level access to the allocator backend % allocator => allocator end select backend % xthreads = dim3 ( SZ , 1 , 1 ) backend % xblocks = dim3 ( globs % n_groups_x , 1 , 1 ) backend % ythreads = dim3 ( SZ , 1 , 1 ) backend % yblocks = dim3 ( globs % n_groups_y , 1 , 1 ) backend % zthreads = dim3 ( SZ , 1 , 1 ) backend % zblocks = dim3 ( globs % n_groups_z , 1 , 1 ) backend % nx_loc = globs % nx_loc backend % ny_loc = globs % ny_loc backend % nz_loc = globs % nz_loc n_halo = 4 n_block = globs % n_groups_x allocate ( backend % u_send_s_dev ( SZ , n_halo , n_block )) allocate ( backend % u_send_e_dev ( SZ , n_halo , n_block )) allocate ( backend % u_recv_s_dev ( SZ , n_halo , n_block )) allocate ( backend % u_recv_e_dev ( SZ , n_halo , n_block )) allocate ( backend % v_send_s_dev ( SZ , n_halo , n_block )) allocate ( backend % v_send_e_dev ( SZ , n_halo , n_block )) allocate ( backend % v_recv_s_dev ( SZ , n_halo , n_block )) allocate ( backend % v_recv_e_dev ( SZ , n_halo , n_block )) allocate ( backend % w_send_s_dev ( SZ , n_halo , n_block )) allocate ( backend % w_send_e_dev ( SZ , n_halo , n_block )) allocate ( backend % w_recv_s_dev ( SZ , n_halo , n_block )) allocate ( backend % w_recv_e_dev ( SZ , n_halo , n_block )) allocate ( backend % du_send_s_dev ( SZ , 1 , n_block )) allocate ( backend % du_send_e_dev ( SZ , 1 , n_block )) allocate ( backend % du_recv_s_dev ( SZ , 1 , n_block )) allocate ( backend % du_recv_e_dev ( SZ , 1 , n_block )) allocate ( backend % dud_send_s_dev ( SZ , 1 , n_block )) allocate ( backend % dud_send_e_dev ( SZ , 1 , n_block )) allocate ( backend % dud_recv_s_dev ( SZ , 1 , n_block )) allocate ( backend % dud_recv_e_dev ( SZ , 1 , n_block )) allocate ( backend % d2u_send_s_dev ( SZ , 1 , n_block )) allocate ( backend % d2u_send_e_dev ( SZ , 1 , n_block )) allocate ( backend % d2u_recv_s_dev ( SZ , 1 , n_block )) allocate ( backend % d2u_recv_e_dev ( SZ , 1 , n_block )) end function init subroutine alloc_cuda_tdsops ( & self , tdsops , n , dx , operation , scheme , & n_halo , from_to , bc_start , bc_end , sym , c_nu , nu0_nu & ) implicit none class ( cuda_backend_t ) :: self class ( tdsops_t ), allocatable , intent ( inout ) :: tdsops integer , intent ( in ) :: n real ( dp ), intent ( in ) :: dx character ( * ), intent ( in ) :: operation , scheme integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to , bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu allocate ( cuda_tdsops_t :: tdsops ) select type ( tdsops ) type is ( cuda_tdsops_t ) tdsops = cuda_tdsops_t ( n , dx , operation , scheme , n_halo , from_to , & bc_start , bc_end , sym , c_nu , nu0_nu ) end select end subroutine alloc_cuda_tdsops subroutine transeq_x_cuda ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps call self % transeq_cuda_dist ( du , dv , dw , u , v , w , dirps , & self % xblocks , self % xthreads ) end subroutine transeq_x_cuda subroutine transeq_y_cuda ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass v, u, w call self % transeq_cuda_dist ( dv , du , dw , v , u , w , dirps , & self % yblocks , self % ythreads ) end subroutine transeq_y_cuda subroutine transeq_z_cuda ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass w, u, v call self % transeq_cuda_dist ( dw , du , dv , w , u , v , dirps , & self % zblocks , self % zthreads ) end subroutine transeq_z_cuda subroutine transeq_cuda_dist ( self , du , dv , dw , u , v , w , dirps , & blocks , threads ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps type ( dim3 ), intent ( in ) :: blocks , threads class ( field_t ), pointer :: temp_du , temp_duu , temp_d2u , & temp_dv , temp_dvu , temp_d2v , & temp_dw , temp_dwu , temp_d2w real ( dp ), device , pointer , dimension (:, :, :) :: & du_dev , duu_dev , d2u_dev , & dv_dev , dvu_dev , d2v_dev , & dw_dev , dwu_dev , d2w_dev real ( dp ), device , pointer , dimension (:, :, :) :: u_dev , v_dev , w_dev , & ru_dev , rv_dev , rw_dev type ( cuda_tdsops_t ), pointer :: der1st , der1st_sym , der2nd , der2nd_sym select type ( u ); type is ( cuda_field_t ); u_dev => u % data_d ; end select select type ( v ); type is ( cuda_field_t ); v_dev => v % data_d ; end select select type ( w ); type is ( cuda_field_t ); w_dev => w % data_d ; end select select type ( du ); type is ( cuda_field_t ); ru_dev => du % data_d ; end select select type ( dv ); type is ( cuda_field_t ); rv_dev => dv % data_d ; end select select type ( dw ); type is ( cuda_field_t ); rw_dev => dw % data_d ; end select select type ( tdsops => dirps % der1st ) type is ( cuda_tdsops_t ); der1st => tdsops end select select type ( tdsops => dirps % der1st_sym ) type is ( cuda_tdsops_t ); der1st_sym => tdsops end select select type ( tdsops => dirps % der2nd ) type is ( cuda_tdsops_t ); der2nd => tdsops end select select type ( tdsops => dirps % der2nd_sym ) type is ( cuda_tdsops_t ); der2nd_sym => tdsops end select ! Copy halo data into buffer arrays call copy_into_buffers ( self % u_send_s_dev , self % u_send_e_dev , u_dev , & dirps % n ) call copy_into_buffers ( self % v_send_s_dev , self % v_send_e_dev , v_dev , & dirps % n ) call copy_into_buffers ( self % w_send_s_dev , self % w_send_e_dev , w_dev , & dirps % n ) ! halo exchange call sendrecv_3fields ( & self % u_recv_s_dev , self % u_recv_e_dev , & self % v_recv_s_dev , self % v_recv_e_dev , & self % w_recv_s_dev , self % w_recv_e_dev , & self % u_send_s_dev , self % u_send_e_dev , & self % v_send_s_dev , self % v_send_e_dev , & self % w_send_s_dev , self % w_send_e_dev , & SZ * 4 * blocks % x , dirps % nproc , dirps % pprev , dirps % pnext & ) ! get some fields for storing the result temp_du => self % allocator % get_block () temp_duu => self % allocator % get_block () temp_d2u => self % allocator % get_block () select type ( temp_du ) type is ( cuda_field_t ); du_dev => temp_du % data_d end select select type ( temp_duu ) type is ( cuda_field_t ); duu_dev => temp_duu % data_d end select select type ( temp_d2u ) type is ( cuda_field_t ); d2u_dev => temp_d2u % data_d end select call exec_dist_transeq_3fused ( & ru_dev , & u_dev , self % u_recv_s_dev , self % u_recv_e_dev , & u_dev , self % u_recv_s_dev , self % u_recv_e_dev , & du_dev , duu_dev , d2u_dev , & self % du_send_s_dev , self % du_send_e_dev , & self % du_recv_s_dev , self % du_recv_e_dev , & self % dud_send_s_dev , self % dud_send_e_dev , & self % dud_recv_s_dev , self % dud_recv_e_dev , & self % d2u_send_s_dev , self % d2u_send_e_dev , & self % d2u_recv_s_dev , self % d2u_recv_e_dev , & der1st , der2nd , self % nu , & dirps % nproc , dirps % pprev , dirps % pnext , & blocks , threads & ) ! Release temporary blocks call self % allocator % release_block ( temp_du ) call self % allocator % release_block ( temp_duu ) call self % allocator % release_block ( temp_d2u ) temp_dv => self % allocator % get_block () temp_dvu => self % allocator % get_block () temp_d2v => self % allocator % get_block () select type ( temp_dv ) type is ( cuda_field_t ); dv_dev => temp_dv % data_d end select select type ( temp_dvu ) type is ( cuda_field_t ); dvu_dev => temp_dvu % data_d end select select type ( temp_d2v ) type is ( cuda_field_t ); d2v_dev => temp_d2v % data_d end select call exec_dist_transeq_3fused ( & rv_dev , & v_dev , self % v_recv_s_dev , self % v_recv_e_dev , & u_dev , self % u_recv_s_dev , self % u_recv_e_dev , & dv_dev , dvu_dev , d2v_dev , & self % du_send_s_dev , self % du_send_e_dev , & self % du_recv_s_dev , self % du_recv_e_dev , & self % dud_send_s_dev , self % dud_send_e_dev , & self % dud_recv_s_dev , self % dud_recv_e_dev , & self % d2u_send_s_dev , self % d2u_send_e_dev , & self % d2u_recv_s_dev , self % d2u_recv_e_dev , & der1st_sym , der2nd_sym , self % nu , & dirps % nproc , dirps % pprev , dirps % pnext , & blocks , threads & ) ! Release temporary blocks call self % allocator % release_block ( temp_dv ) call self % allocator % release_block ( temp_dvu ) call self % allocator % release_block ( temp_d2v ) temp_dw => self % allocator % get_block () temp_dwu => self % allocator % get_block () temp_d2w => self % allocator % get_block () select type ( temp_dw ) type is ( cuda_field_t ); dw_dev => temp_dw % data_d end select select type ( temp_dwu ) type is ( cuda_field_t ); dwu_dev => temp_dwu % data_d end select select type ( temp_d2w ) type is ( cuda_field_t ); d2w_dev => temp_d2w % data_d end select call exec_dist_transeq_3fused ( & rw_dev , & w_dev , self % w_recv_s_dev , self % w_recv_e_dev , & u_dev , self % u_recv_s_dev , self % u_recv_e_dev , & dw_dev , dwu_dev , d2w_dev , & self % du_send_s_dev , self % du_send_e_dev , & self % du_recv_s_dev , self % du_recv_e_dev , & self % dud_send_s_dev , self % dud_send_e_dev , & self % dud_recv_s_dev , self % dud_recv_e_dev , & self % d2u_send_s_dev , self % d2u_send_e_dev , & self % d2u_recv_s_dev , self % d2u_recv_e_dev , & der1st_sym , der2nd_sym , self % nu , & dirps % nproc , dirps % pprev , dirps % pnext , & blocks , threads & ) ! Release temporary blocks call self % allocator % release_block ( temp_dw ) call self % allocator % release_block ( temp_dwu ) call self % allocator % release_block ( temp_d2w ) end subroutine transeq_cuda_dist subroutine transeq_cuda_thom ( self , du , dv , dw , u , v , w , dirps ) !! Thomas algorithm implementation. So much more easier than the !! distributed algorithm. It is intended to work only on a single rank !! so there is no MPI communication. implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps end subroutine transeq_cuda_thom subroutine tds_solve_cuda ( self , du , u , dirps , tdsops ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u type ( dirps_t ), intent ( in ) :: dirps class ( tdsops_t ), intent ( in ) :: tdsops type ( dim3 ) :: blocks , threads blocks = dim3 ( dirps % n_blocks , 1 , 1 ); threads = dim3 ( SZ , 1 , 1 ) call tds_solve_dist ( self , du , u , dirps , tdsops , blocks , threads ) end subroutine tds_solve_cuda subroutine tds_solve_dist ( self , du , u , dirps , tdsops , blocks , threads ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u type ( dirps_t ), intent ( in ) :: dirps class ( tdsops_t ), intent ( in ) :: tdsops type ( dim3 ), intent ( in ) :: blocks , threads real ( dp ), device , pointer , dimension (:, :, :) :: du_dev , u_dev type ( cuda_tdsops_t ), pointer :: tdsops_dev select type ( du ); type is ( cuda_field_t ); du_dev => du % data_d ; end select select type ( u ); type is ( cuda_field_t ); u_dev => u % data_d ; end select select type ( tdsops ) type is ( cuda_tdsops_t ); tdsops_dev => tdsops end select call copy_into_buffers ( self % u_send_s_dev , self % u_send_e_dev , u_dev , & tdsops_dev % n ) call sendrecv_fields ( self % u_recv_s_dev , self % u_recv_e_dev , & self % u_send_s_dev , self % u_send_e_dev , & SZ * 4 * blocks % x , dirps % nproc , & dirps % pprev , dirps % pnext ) ! call exec_dist call exec_dist_tds_compact ( & du_dev , u_dev , & self % u_recv_s_dev , self % u_recv_e_dev , & self % du_send_s_dev , self % du_send_e_dev , & self % du_recv_s_dev , self % du_recv_e_dev , & tdsops_dev , dirps % nproc , dirps % pprev , dirps % pnext , & blocks , threads & ) end subroutine tds_solve_dist subroutine reorder_cuda ( self , u_o , u_i , direction ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: u_o class ( field_t ), intent ( in ) :: u_i integer , intent ( in ) :: direction real ( dp ), device , pointer , dimension (:, :, :) :: u_o_d , u_i_d type ( dim3 ) :: blocks , threads select type ( u_o ); type is ( cuda_field_t ); u_o_d => u_o % data_d ; end select select type ( u_i ); type is ( cuda_field_t ); u_i_d => u_i % data_d ; end select select case ( direction ) case ( RDR_X2Y ) ! x2y blocks = dim3 ( self % nx_loc / SZ , self % nz_loc , self % ny_loc / SZ ) threads = dim3 ( SZ , SZ , 1 ) call reorder_x2y <<< blocks , threads >>> ( u_o_d , u_i_d , self % nz_loc ) case ( RDR_X2Z ) ! x2z blocks = dim3 ( self % nx_loc , self % ny_loc / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call reorder_x2z <<< blocks , threads >>> ( u_o_d , u_i_d , self % nz_loc ) case ( RDR_Y2X ) ! y2x blocks = dim3 ( self % nx_loc / SZ , self % ny_loc / SZ , self % nz_loc ) threads = dim3 ( SZ , SZ , 1 ) call reorder_y2x <<< blocks , threads >>> ( u_o_d , u_i_d , self % nz_loc ) case ( RDR_Y2Z ) ! y2z blocks = dim3 ( self % nx_loc / SZ , self % ny_loc / SZ , self % nz_loc ) threads = dim3 ( SZ , SZ , 1 ) call reorder_y2z <<< blocks , threads >>> ( u_o_d , u_i_d , & self % nx_loc , self % nz_loc ) case ( RDR_Z2X ) ! z2x blocks = dim3 ( self % nx_loc , self % ny_loc / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call reorder_z2x <<< blocks , threads >>> ( u_o_d , u_i_d , self % nz_loc ) case ( RDR_Z2Y ) ! z2y blocks = dim3 ( self % nx_loc / SZ , self % ny_loc / SZ , self % nz_loc ) threads = dim3 ( SZ , SZ , 1 ) call reorder_z2y <<< blocks , threads >>> ( u_o_d , u_i_d , & self % nx_loc , self % nz_loc ) case default error stop 'Reorder direction is undefined.' end select end subroutine reorder_cuda subroutine sum_yintox_cuda ( self , u , u_y ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_y real ( dp ), device , pointer , dimension (:, :, :) :: u_d , u_y_d type ( dim3 ) :: blocks , threads select type ( u ); type is ( cuda_field_t ); u_d => u % data_d ; end select select type ( u_y ); type is ( cuda_field_t ); u_y_d => u_y % data_d ; end select blocks = dim3 ( self % nx_loc / SZ , self % ny_loc / SZ , self % nz_loc ) threads = dim3 ( SZ , SZ , 1 ) call sum_yintox <<< blocks , threads >>> ( u_d , u_y_d , self % nz_loc ) end subroutine sum_yintox_cuda subroutine sum_zintox_cuda ( self , u , u_z ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_z real ( dp ), device , pointer , dimension (:, :, :) :: u_d , u_z_d type ( dim3 ) :: blocks , threads select type ( u ); type is ( cuda_field_t ); u_d => u % data_d ; end select select type ( u_z ); type is ( cuda_field_t ); u_z_d => u_z % data_d ; end select blocks = dim3 ( self % nx_loc , self % ny_loc / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call sum_zintox <<< blocks , threads >>> ( u_d , u_z_d , self % nz_loc ) end subroutine sum_zintox_cuda subroutine vecadd_cuda ( self , a , x , b , y ) implicit none class ( cuda_backend_t ) :: self real ( dp ), intent ( in ) :: a class ( field_t ), intent ( in ) :: x real ( dp ), intent ( in ) :: b class ( field_t ), intent ( inout ) :: y real ( dp ), device , pointer , dimension (:, :, :) :: x_d , y_d type ( dim3 ) :: blocks , threads integer :: nx select type ( x ); type is ( cuda_field_t ); x_d => x % data_d ; end select select type ( y ); type is ( cuda_field_t ); y_d => y % data_d ; end select nx = size ( x_d , dim = 2 ) blocks = dim3 ( size ( x_d , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call axpby <<< blocks , threads >>> ( nx , a , x_d , b , y_d ) end subroutine vecadd_cuda real ( dp ) function scalar_product_cuda ( self , x , y ) result ( s ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( in ) :: x , y real ( dp ), device , pointer , dimension (:, :, :) :: x_d , y_d real ( dp ), device , allocatable :: sum_d type ( dim3 ) :: blocks , threads integer :: n , ierr select type ( x ); type is ( cuda_field_t ); x_d => x % data_d ; end select select type ( y ); type is ( cuda_field_t ); y_d => y % data_d ; end select allocate ( sum_d ) sum_d = 0._dp n = size ( x_d , dim = 2 ) blocks = dim3 ( size ( x_d , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call scalar_product <<< blocks , threads >>> ( sum_d , x_d , y_d , n ) s = sum_d call MPI_Allreduce ( MPI_IN_PLACE , s , 1 , MPI_DOUBLE_PRECISION , MPI_SUM , & MPI_COMM_WORLD , ierr ) end function scalar_product_cuda subroutine copy_into_buffers ( u_send_s_dev , u_send_e_dev , u_dev , n ) implicit none real ( dp ), device , dimension (:, :, :), intent ( out ) :: u_send_s_dev , & u_send_e_dev real ( dp ), device , dimension (:, :, :), intent ( in ) :: u_dev integer , intent ( in ) :: n type ( dim3 ) :: blocks , threads integer :: n_halo = 4 blocks = dim3 ( size ( u_dev , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call buffer_copy <<< blocks , threads >>> ( u_send_s_dev , u_send_e_dev , & u_dev , n , n_halo ) end subroutine copy_into_buffers subroutine set_field_cuda ( self , f , arr ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), dimension (:, :, :), intent ( in ) :: arr select type ( f ); type is ( cuda_field_t ); f % data_d = arr ; end select end subroutine set_field_cuda subroutine get_field_cuda ( self , arr , f ) implicit none class ( cuda_backend_t ) :: self real ( dp ), dimension (:, :, :), intent ( out ) :: arr class ( field_t ), intent ( in ) :: f select type ( f ); type is ( cuda_field_t ); arr = f % data_d ; end select end subroutine get_field_cuda subroutine init_cuda_poisson_fft ( self , xdirps , ydirps , zdirps ) implicit none class ( cuda_backend_t ) :: self type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps allocate ( cuda_poisson_fft_t :: self % poisson_fft ) select type ( poisson_fft => self % poisson_fft ) type is ( cuda_poisson_fft_t ) poisson_fft = cuda_poisson_fft_t ( xdirps , ydirps , zdirps ) end select end subroutine init_cuda_poisson_fft end module m_cuda_backend","tags":"","loc":"sourcefile/backend.f90~3.html"}]}